/**
 *
 */
export interface ColumnGroupMeta {
  /**
   *
   */
  readonly colIdToGroupIds: Map<string, string[]>;

  /**
   *
   */
  readonly validGroupIds: Set<string>;

  /**
   *
   */
  readonly groupIsCollapsible: Map<string, boolean>;
}

/**
 *
 */
export type ColumnGroupVisibility = "always" | "close" | "open";

/**
 *
 */
export type ColumnPin = "start" | "end" | null;

/**
 *
 */
export interface RowDataStore<T> {
  /**
   *
   */
  readonly rowCount: GridAtomReadonly<number>;

  /**
   *
   */
  readonly rowTopCount: GridAtom<number>;

  /**
   *
   */
  readonly rowCenterCount: GridAtom<number>;

  /**
   *
   */
  readonly rowBottomCount: GridAtom<number>;

  /**
   *
   */
  readonly rowForIndex: (
    row: number,
  ) => GridAtomReadonlyUnwatchable<RowNode<T> | null>;

  /**
   *
   */
  readonly rowClearCache: () => void;

  /**
   *
   */
  readonly rowInvalidateIndex: (row: number) => void;
}

/**
 *
 */
export interface GridAtom<T> {
  /**
   *
   */
  readonly get: () => T;

  /**
   *
   */
  readonly set: (v: T | ((p: T) => T)) => void;

  /**
   *
   */
  readonly watch: (fn: () => void) => () => void;

  /**
   *
   */
  readonly useValue: () => T;
}

/**
 *
 */
export interface GridAtomReadonly<T> {
  /**
   *
   */
  readonly get: () => T;

  /**
   *
   */
  readonly watch: (fn: () => void) => () => void;

  /**
   *
   */
  readonly useValue: () => T;
}

/**
 *
 */
export interface GridAtomReadonlyUnwatchable<T> {
  /**
   *
   */
  readonly get: () => T;

  /**
   *
   */
  readonly useValue: () => T;
}

/**
 * The union type of {@link RowLeaf} and {@link RowGroup}. A row node is a any row that may be
 * displayed in the grid or used for data aggregation purposes.
 *
 * See:
 * - [Row Nodes](TODO): Learn more about the row nodes in the grid
 */
export type RowNode<T> = RowLeaf<T> | RowGroup;

/**
 * The leaf row type. As the name suggests, leaf rows do not have any further children rows
 * underneath them. Leaf rows are generally used to derivate aggregations and groupings. A
 * complete flat data grid will only have leaf rows.
 */
export interface RowLeaf<T = any> {
  /**
   * A unique `id` for a given row. The `id` is generated by a given {@link RowDataSource}.
   * Every row should have a unique `id` associated with.
   *
   * See:
   * - [Row Data Source](TODO): Learn how rows are created and updated.
   */
  readonly id: string;

  /**
   * An optional property that indicates if a row is loading data. Primarily used to support
   * asynchronous row loading.
   *
   * See:
   * - [Async Row Data Source](TODO): An asynchronous row data source
   */
  readonly loading?: boolean;

  /**
   * An error associated with a row. This is implementation dependent. The type is not known
   * ahead of time, and should be checked for interacting with the error value.
   */
  readonly error?: unknown;

  /**
   * A type discriminant used to narrow the {@link RowNode} type to a {@link RowLeaf} type.
   */
  readonly kind: "leaf";

  /**
   * The data associated with the row. The data may be any type but is normally a plain
   * JavaScript object or array. The row data is provided to a column field to determine
   * the value for a given cell for a particular column.
   *
   * See:
   * - {@link Column}: Column's use a row's data field to determine the value of a cell.
   * - {@link ColumnField}: The column field determines how a cell's value is calculated.
   * - [Column Field](TODO): See the full guide on column fields and learn how cell values are determined.
   */
  readonly data: T;
}

/**
 * The branch row type represents a row that has more rows underneath it, considered its child
 * rows. A branch row may be expanded (in which case the children rows will be visible) or
 * collapsed (in which case the children rows will not be visible). The children rows may be
 * {@link RowLeaf} or {@link RowGroup} rows.
 */
export interface RowGroup {
  /**
   * A unique `id` for a given row. The `id` is generated by a given {@link RowDataSource}.
   * Every row should have a unique `id` associated with.
   *
   * See:
   * - [Row Data Source](TODO): Learn how rows are created and updated.
   */
  readonly id: string;

  /**
   * An optional property that indicates if a row is loading data. Primarily used to support
   * asynchronous row loading.
   *
   * See:
   * - [Async Row Data Source](TODO): An asynchronous row data source
   */
  readonly loading?: boolean;

  /**
   * An error associated with a row. This is implementation dependent. The type is not known
   * ahead of time, and should be checked for interacting with the error value.
   */
  readonly error?: unknown;

  /**
   * A type discriminant used to narrow the {@link RowNode} to the {@link RowGroup} type.
   */
  readonly kind: "branch";

  /**
   * A path key associated with the branch node. The view of the grid is a flattened tree. A
   * branch represents a fork in the tree, and the key is the path value associated with that
   * fork.
   */
  readonly key: string | null;

  /**
   * The data associated with the branch node. This must be a JavaScript object with string values
   * for the key. The data values may be any type. This data is usually the result of aggregating
   * the children rows of a branch node, but this is not strictly enforced.
   */
  readonly data: Record<string, unknown>;

  /**
   *
   */
  readonly depth: number;
}

/**
 *
 */
export interface SortDateComparatorOptions {
  /**
   *
   */
  readonly nullsFirst?: boolean;

  /**
   *
   */
  readonly toIsoDateString?: (v: unknown) => string;

  /**
   *
   */
  readonly includeTime?: boolean;
}

/**
 *
 */
export interface SortNumberComparatorOptions {
  /**
   *
   */
  readonly nullsFirst?: boolean;

  /**
   *
   */
  readonly absoluteValue?: boolean;
}

/**
 *
 */
export interface SortStringComparatorOptions {
  /**
   *
   */
  readonly caseInsensitive?: boolean;

  /**
   *
   */
  readonly trimWhitespace?: boolean;

  /**
   *
   */
  readonly ignorePunctuation?: boolean;

  /**
   *
   */
  readonly locale?: string;

  /**
   *
   */
  readonly collator?: Intl.Collator;

  /**
   *
   */
  readonly nullsFirst?: boolean;
}

/**
 *
 */
export interface FilterDate {
  /**
   *
   */
  readonly kind: "date";

  /**
   *
   */
  readonly field: string;

  /**
   *
   */
  readonly operator: FilterDateOperator;

  /**
   *
   */
  readonly value: string | number | null;

  /**
   *
   */
  readonly options?: FilterDateOptions;
}

/**
 * The operators available for the date filter. The operator used determines the type of
 * value that should be used.
 */
export type FilterDateOperator =
  | "equals"
  | "not_equals"
  | "before"
  | "before_or_equals"
  | "after"
  | "after_or_equals"
  | "year_to_date"
  | "this_week"
  | "this_month"
  | "this_year"
  | "last_week"
  | "last_month"
  | "last_year"
  | "next_week"
  | "next_month"
  | "next_year"
  | "today"
  | "tomorrow"
  | "yesterday"
  | "week_of_year"
  | "quarter_of_year"
  | "is_weekend"
  | "is_weekday"
  | "n_days_ago"
  | "n_days_ahead"
  | "n_weeks_ago"
  | "n_weeks_ahead"
  | "n_months_ago"
  | "n_months_ahead"
  | "n_years_ago"
  | "n_years_ahead";

/**
 *
 */
export interface FilterDateOptions {
  /**
   * When filtering `null` values represent the absence of a value. Since there is not value
   * to compare the filter on - there are two choices; keep the value, or filter it out. The
   * `nullHandling` property determines which option to take, where `"ignore"` will filter
   * out null values and `"include"` will keep them.
   *
   * It's important to note that filtering is performed by the row data source attached to the
   * grid, hence the actual behavior depends on the source. A properly behaving data source will
   * filter `null` values accordingly but not all sources may choose to do this. Furthermore,
   * depending on the operator used for the filter, the `nullHandling` property may be ignored.
   * For example, when comparing for equality ('===') the filter implementation should check that
   * the current value is equal to the filter value - including the absence of a value. Intuitively
   * this makes sense as it allows the equality operator to be used to check for `null` values
   * themselves.
   */
  readonly nullHandling?: "ignore" | "include";

  /**
   * If the time should be used for date filter evaluations. By default only the date is
   * considered. Setting the `includeTime` to `true` will make the comparisons time aware.
   */
  readonly includeTime?: boolean;
}

/**
 * The number filter is used to filter out rows based on a column that contains number values.
 * Most useful for numerical datasets.
 *
 * See:
 * - [Filters](TODO): Overview of the filters
 */
export interface FilterNumber {
  /**
   * A type discriminant for the {@link FilterNumber} type, which may be used to narrow the
   * the type when given a set of filters. Mainly used in the evaluation of filters, for example
   * a {@link FilterCombination} accepts filters of different types.
   */
  readonly kind: "number";

  /**
   * The column reference the filter should use. This is used to extract a field value for the
   * filter for a given row. This should be the `id` of a column.
   */
  readonly field: string;

  /**
   * The number filter operator to use when evaluating the filter. This value should be the string
   * name of the operator, for example "equals" and not "==".
   */
  readonly operator: FilterNumberOperator;

  /**
   * The filter value to compare with. The actual filter evaluation outcome is determined by the
   * operator applied.
   */
  readonly value: number | null;

  /**
   * The filter number options to apply to the filter. Filter options alter the evaluation result
   * of a filter, for example using the absolute value of a number when performing the operator
   * calculation.
   */
  readonly options?: FilterNumberOptions;
}

/**
 * The operators that may be used for the a number filter. These correspond to the standard expected
 * logical operators, like >, and <.
 */
export type FilterNumberOperator =
  | "greater_than"
  | "greater_than_or_equals"
  | "less_than"
  | "less_than_or_equals"
  | "equals"
  | "not_equals";

/**
 * The filter options that may be provided to a number filter. The filter options will adjust
 * how the number filter behaves providing more flexibility to less effort.
 */
export interface FilterNumberOptions {
  /**
   * Makes the number filter only consider the magnitude of a number value ignoring its sign.
   * Useful when the size of the number is the main consideration.
   */
  readonly absolute?: boolean;

  /**
   * The epsilon value to use when comparing numbers. Mostly useful when comparing floats. By
   * default the value is 0.0001 however it may be adjusted for higher or lower precision.
   */
  readonly epsilon?: number;

  /**
   * When filtering `null` values represent the absence of a value. Since there is not value
   * to compare the filter on - there are two choices; keep the value, or filter it out. The
   * `nullHandling` property determines which option to take, where `"ignore"` will filter
   * out null values and `"include"` will keep them.
   *
   * It's important to note that filtering is performed by the row data source attached to the
   * grid, hence the actual behavior depends on the source. A properly behaving data source will
   * filter `null` values accordingly but not all sources may choose to do this. Furthermore,
   * depending on the operator used for the filter, the `nullHandling` property may be ignored.
   * For example, when comparing for equality ('===') the filter implementation should check that
   * the current value is equal to the filter value - including the absence of a value. Intuitively
   * this makes sense as it allows the equality operator to be used to check for `null` values
   * themselves.
   */
  readonly nullHandling?: "ignore" | "include";
}

/**
 * The string filter used to evaluate values that are string based. Used to filter out rows based
 * on the string values of a particular column.
 */
export interface FilterString {
  /**
   * A type discriminant for the {@link FilterString} type, which may be used to narrow the
   * the type when given a set of filters. Mainly used in the evaluation of filters, for example
   * a {@link FilterCombination} accepts filters of different types.
   */
  readonly kind: "string";

  /**
   * The column reference the filter should use. This is used to extract a field value for the
   * filter for a given row. This should be the `id` of a column.
   */
  readonly field: string;

  /**
   * The string filter operator to use when evaluating the filter. This value should be the string
   * name of the operator, for example "equals" and not "==".
   */
  readonly operator: FilterStringOperator;

  /**
   * The string filter evaluation value. For some filter operators a `number` value makes
   * sense, for example, when comparing the lengths of strings. It is an undefined error to
   * use a `number` value where a filter operator expects a `string`.
   */
  readonly value: string | number | null;

  /**
   * The options to apply for the string filter evaluation. The string options may be used to
   * alter the behavior of filter evaluation, for example to make comparisons case insensitive.
   */
  readonly options?: FilterStringOptions;
}

/**
 * The string collation options used to create an Intl.Collator object that will be used for
 * string comparisons.
 */
export interface FilterStringCollation {
  /**
   * The locale to use for string comparisons and operators. It should be one of the predefined
   * types. If not provided the default locale on the system is used.
   */
  readonly locale: Locale;

  /**
   * The locale sensitivity - used to construct an Intl.Collator object. Refer to the
   * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator)
   * for more information.
   */
  readonly sensitivity?: Intl.CollatorOptions["sensitivity"];
}

/**
 * The filter operator for strings. Some operators expect the value provided to be a number,
 * for example when comparing the length of strings.
 */
export type FilterStringOperator =
  | "equals"
  | "not_equals"
  | "less_than"
  | "less_than_or_equals"
  | "greater_than"
  | "greater_than_or_equals"
  | "begins_with"
  | "not_begins_with"
  | "ends_with"
  | "not_ends_with"
  | "contains"
  | "not_contains"
  | "length"
  | "not_length"
  | "matches"
  | "length_less_than"
  | "length_less_than_or_equals"
  | "length_greater_than"
  | "length_greater_than_or_equals";

/**
 * The options to use for filter string evaluation. The options allow filter evaluation behavior
 * to be altered in specific ways, such as ignoring letter casing, trimming whitespace, and
 * ignoring punctuation. The filter string options additionally allow a locale to be used for
 * string filtering.
 */
export interface FilterStringOptions {
  /**
   * The regex opts to use for the construction of a regex object to use for the `matches`
   * string filter operator. See the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#advanced_searching_with_flags)
   * for information on the different flags.
   */
  readonly regexOpts?: string;

  /**
   * A flag to determine if whitespace should be stripped before string comparisons. This will
   * result in leading and trailing whitespace to be ignored when performing string comparisons.
   */
  readonly trimWhitespace?: boolean;

  /**
   * A flag indicating if the comparison should be case insensitive. By default comparisons
   * are case insensitive if the filter value does not contain an upper case letter. However,
   * depending on the collator sensitivity the default value may
   * actually be case insensitive. For example a collator sensitivity of `"base"` or
   * `"accent"` result in case case insensitive comparisons.
   */
  readonly caseInsensitive?: boolean;

  /**
   * If punctuation characters should be ignored when performing string comparisons. By default
   * punctuation is considered.
   */
  readonly ignorePunctuation?: boolean;

  /**
   * When filtering `null` values represent the absence of a value. Since there is not value
   * to compare the filter on - there are two choices; keep the value, or filter it out. The
   * `nullHandling` property determines which option to take, where `"ignore"` will filter
   * out null values and `"include"` will keep them.
   *
   * It's important to note that filtering is performed by the row data source attached to the
   * grid, hence the actual behavior depends on the source. A properly behaving data source will
   * filter `null` values accordingly but not all sources may choose to do this. Furthermore,
   * depending on the operator used for the filter, the `nullHandling` property may be ignored.
   * For example, when comparing for equality ('===') the filter implementation should check that
   * the current value is equal to the filter value - including the absence of a value. Intuitively
   * this makes sense as it allows the equality operator to be used to check for `null` values
   * themselves.
   */
  readonly nullHandling?: "ignore" | "include";

  /**
   * The collation parameters to use for the filter evaluation. If provided these parameters will
   * be used to create an `Intl.Collator` object that is then used in the comparison operator
   * for filter evaluation.
   */
  readonly collation?: FilterStringCollation;
}

/**
 *
 */
export type Locale =
  | "en-US"
  | "en-GB"
  | "en-CA"
  | "en-AU"
  | "en-IN"
  | "fr-FR"
  | "fr-CA"
  | "fr-BE"
  | "fr-CH"
  | "es-ES"
  | "es-MX"
  | "es-AR"
  | "es-CO"
  | "zh-CN"
  | "zh-TW"
  | "zh-HK"
  | "zh-Hant"
  | "zh-Hans"
  | "ar-SA"
  | "ar-EG"
  | "ar-AE"
  | "de-DE"
  | "de-AT"
  | "de-CH"
  | "ja-JP"
  | "ko-KR"
  | "hi-IN"
  | "pt-BR"
  | "pt-PT"
  | "ru-RU"
  | "uk-UA"
  | "pl-PL"
  | "it-IT"
  | "nl-NL"
  | "sv-SE"
  | "tr-TR"
  | "th-TH"
  | "vi-VN"
  | "he-IL"
  | "fa-IR"
  | "el-GR";

/**
 *
 */
export interface PositionFloatingCell {
  /**
   *
   */
  readonly kind: "floating-cell";

  /**
   *
   */
  readonly colIndex: number;
}

/**
 *
 */
export interface PositionFullWidthRow {
  /**
   *
   */
  readonly kind: "full-width";

  /**
   *
   */
  readonly rowIndex: number;

  /**
   *
   */
  readonly colIndex: number;
}

/**
 *
 */
export interface PositionGridCell {
  /**
   *
   */
  readonly kind: "cell";

  /**
   *
   */
  readonly rowIndex: number;

  /**
   *
   */
  readonly colIndex: number;

  /**
   *
   */
  readonly root: PositionGridCellRoot | null;
}

/**
 *
 */
export interface PositionGridCellRoot {
  /**
   *
   */
  readonly colIndex: number;

  /**
   *
   */
  readonly rowIndex: number;

  /**
   *
   */
  readonly rowSpan: number;

  /**
   *
   */
  readonly colSpan: number;
}

/**
 *
 */
export interface PositionHeaderCell {
  /**
   *
   */
  readonly kind: "header-cell";

  /**
   *
   */
  readonly colIndex: number;
}

/**
 *
 */
export interface PositionHeaderGroupCell {
  /**
   *
   */
  readonly kind: "header-group-cell";

  /**
   *
   */
  readonly columnStartIndex: number;

  /**
   *
   */
  readonly columnEndIndex: number;

  /**
   *
   */
  readonly hierarchyRowIndex: number;

  /**
   *
   */
  readonly colIndex: number;
}

/**
 *
 */
export type PositionUnion =
  | PositionGridCell
  | PositionFloatingCell
  | PositionHeaderCell
  | PositionFullWidthRow
  | PositionHeaderGroupCell;
