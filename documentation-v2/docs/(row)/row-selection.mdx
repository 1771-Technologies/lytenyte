---
title: Row Selection
step: Select single or multiple rows.
description: Select individual or multiple rows using LyteNyte Grid's row selection
  system. Easily implement checkbox-based selection with support for bulk operations.
---

## Enabling Row Selection

The `rowSelectionMode` property on LyteNyte Grid configures the row selection behavior the grid uses.
It accepts one of the following values:

- `"none"`: Disables all built-in row selection behavior and prevents user interactions
  from selecting rows.
- `"single"`: Allows the user to select a single row. Selecting a new row clears any existing selection.
- `"multiple"`: Allows multiple rows to be selected, including additive selection behavior.

In addition to `rowSelectionMode`, the `rowSelectionActivator` property controls
which user action selects a row. It accepts one of the following values:

- `"none"`: Disables all row-based selection interactions. Developers must provide
  a custom selection mechanism, such as selection checkboxes.
- `"single-click"`: Selects a row when the user clicks it.
- `"double-click"`: Selects a row when the user double-clicks it.

The demo below shows single-row selection configured to select a row with
a single click. Other configurations, covered in later sections, support
multiple selection modes or checkbox-based selection.

::demo[Enabling Row Selection="./demos/row-selection"]

### Multiple Row Selection

Set `rowSelectionMode` to `"multiple"` to allow users to select more than one row.
Clicking a row toggles its selection state. Holding **Shift** while clicking
another row selects the range between the two rows.

The demo below demonstrates these interactions.

::demo[Multiple Row Selection="./demos/row-selection-multi"]

## Checkbox Selection

Selecting rows by clicking anywhere on the row can conflict with other grid interactions or diverge
from common UX patterns. A common alternative is checkbox-based row selection.

LyteNyte Grid provides the `api.rowHandleSelect` helper to simplify checkbox selection logic,
including support for shift-based range selection.

::demo[Checkbox Row Selection="./demos/row-selection-checkbox"]

The demo uses `api.rowHandleSelect` to handle checkbox interactions:

```tsx
<GridCheckbox
  checked={selected}
  onClick={(ev) => {
    ev.stopPropagation();
    api.rowHandleSelect({ shiftKey: ev.shiftKey, target: ev.target }); //!
  }}
  onKeyDown={(ev) => {
    if (ev.key === "Enter" || ev.key === " ")
      api.rowHandleSelect({ shiftKey: ev.shiftKey, target: ev.target }); //!
  }}
/>
```

:::tip

Checkbox selection and click selection are **not** mutually exclusive in LyteNyte Grid.
You can use both at the same time. Checkboxes are a great way to indicate to users
that they can select rows.

:::

### Selecting All Rows

The selection checkbox demo includes the ability to select or deselect all rows
in the grid via the [marker column's](/docs/marker-column) header checkbox. The
demo uses the [SelectAll component](/docs/component-select-all). However, you can
perform the same select-all behavior programmatically using the `api.rowSelect`
method, as shown below:

```ts
api.rowSelect({ selected: "all" }); // select all rows
api.rowSelect({ selected: "all", deselect: true }); // deselect all rows
```

Selecting all rows only works if `rowSelectionMode` is set to `"multiple"`.

## Row Selection State

The row selection state is maintained by the row data source provided to the grid.
The selection state determines which rows the grid marks as selected, and which rows are returned
when you request the selected row set.

While each row data source has its own selection state in memory, all LyteNyte Grid data sources use the
same row selection state **representation**.

:::note

The explanation below applies to the built-in LyteNyte Grid
data sources. If you use a custom data source, the behavior described here may not apply.

:::

The row selection state may be one of two types:

- `isolated`: Used when the row selection mode is `"single"` or when `rowsIsolatedSelection`
  is set to `true` on the data source.
- `linked`: Used when the row selection mode is `"multiple"` and when the `rowsIsolatedSelection`
  property is set to `false` on the data source.

The code below shows setting `linked` and `isolated` selection when using the
[client row data source](/docs/client-source-overview). The same property names
are used by all other built-in LyteNyte Grid data sources.

<Tabs>

<Tab label="Isolated">

```tsx
const ds = useClientDataSource({ data: data, rowsIsolatedSelection: true });
```

</Tab>

<Tab label="Linked">

```tsx
// rowsIsolatedSelection is false by default, so it can be omitted.
const ds = useClientDataSource({ data: data, rowsIsolatedSelection: false });
```

</Tab>

</Tabs>

The different row selection state modes primarily differ in how they handle selecting **group rows**.
For flat datasets with no grouping, both modes behave identically.

### Isolated Row Selection

Isolated row selection treats every row as individually selectable. As a TypeScript interface, it
is represented as follows:

```ts
interface RowSelectionIsolated {
  readonly kind: "isolated";
  readonly selected: boolean;
  readonly exceptions: Set<string>;
}
```

With isolated selection, selecting a group row does not select its children, and selecting all the
child rows of a group does not select the parent. Each row maintains its own unique selection state.

`RowSelectionIsolated` works as an exclusion set. The `selected` property determines whether rows
are selected by default. If `selected` is `true`, all rows are selected by default. If `selected` is
`false`, no rows are selected by default. The `exceptions` set contains row IDs that invert the
default selection:

- If `selected` is `true`, any row with an ID in `exceptions` is not selected.
- If `selected` is `false`, any row with an ID in `exceptions` is selected.

The demo below demonstrates isolated row selection. Notice that selecting a group row does not
select its children. This is the intended behavior of isolated row selection.

::demo[Isolated Row Selection="./demos/row-selection-groups"]

### Linked Row Selection

Linked row selection represents selection state as an inclusion/exclusion tree of nodes. The
type interfaces are shown below. The root of the selection tree is the `RowSelectionLinked` type.

```ts
interface RowSelectNode {
  readonly id: string;
  children?: Map<string, RowSelectNode>;
  selected?: boolean;
}

interface RowSelectionLinked {
  readonly kind: "linked";
  readonly selected: boolean;
  readonly children: Map<string, RowSelectNode>;
}
```

The selection state of a row is determined by the closest node to that row in the tree, including the row itself.
For example, consider the tree below. **Node A** is not selected, but its child **Node Y** is selected, so the selection
set includes **Node Y**. **Node X** is not selected because it does not override selection, and its parent is not selected.

On the other hand, **Node B** is selected, so **Node W** and **Node U** are also selected. This gives you a selection
set that includes **Node W** and **Node U**.

```txt
Node A (selected = false)
   |
   | -- Node X
   | -- Node Y (selected = true)
   |
Node B (selected = true)
   |
   | -- Node W
   | -- Node U
   |
```

The linked row representation may appear complex at first, but it has some very desirable properties:

- It compactly represents group selection states, especially when many groups are selected.
- It works even when only a partial set of the rows have been loaded. This is particularly important
  for server data loading, where only some of a group's rows may be available.
- It can be serialized into a string without consuming many characters. This is important when selection state
  must be maintained in the URL of your application.

In addition to these benefits, LyteNyte Grid compacts and collapses redundant nodes in the tree as the
user selects rows. This keeps the tree as flat as possible while still representing the correct selection
state. As a developer, you rarely need to interact with the selection state directly. In most cases, it is
sufficient to call the `rowsSelected` method on the data source or grid API. This method returns the
selected row nodes that are currently available.

The demo below demonstrates linked selection. Selecting all children of a group row selects the group row.
You can also select the group row itself to select all rows under that group.

::demo[Linked Row Selection="./demos/row-selection-groups-linked"]

### Controlling Row Selection State

Each LyteNyte Grid row data source maintains an internal representation of row selection state.
This internal state is **uncontrolled**, similar to the value of an `<input>` element without an `onChange` handler.

You can control this state by setting the `rowSelection` property on the row data source. To listen for
updates, provide an `onRowSelectionChange` callback. For example:

```ts
const [selection, setSelection] = useState<Grid.T.RowSelectionLinked>({
  kind: "linked",
  selected: false,
  children: new Map(),
});

const ds = useClientDataSource({
  rowSelection: selection,
  onRowSelectionChange: setSelection,
});
```

:::warn

LyteNyte Grid's row data sources enforce that the row selection state matches the
`rowsIsolatedSelection` property on the data source. When providing your own row selection
state, ensure that the selection type you pass matches the isolation setting.

:::

## Getting Selected Nodes

All row data sources implement the `rowsSelected` method. Since the method is implemented on the row data
source, the grid API also exposes it. Call it from whichever reference is more convenient.

The `rowsSelected` method returns the selected row nodes for the current row selection state. The
nodes returned depend on the data source. For client-side data sources, such as
the [tree data source](/docs/tree-source-overview), all selected rows are available. For server
data sources, only rows that have been loaded from the server are returned.

The demo below demonstrates fetching selected rows and alerting the user when the **"Alert Rows"**
button is pressed. Use the same callback whenever you want to retrieve selected row data for your application.

::demo[Get Selected Rows="./demos/row-selection-alert"]

The **Alert Rows** button uses the `ds.rowsSelected` method to retrieve the selected rows and alert
the user with the count, as the code below shows:

```tsx
<button
  data-ln-button="tertiary"
  data-ln-size="md"
  //!next 7
  onClick={() => {
    const selected = ds.rowsSelected();

    if (!selected.rows.length) alert("There are currently no rows selected.");
    if (selected.rows.length === 1) alert("1 row selected.");
    if (selected.rows.length > 1) alert(`${selected.rows.length} rows selected.`);
  }}
>
  Alert Rows
</button>
```

## Preventing Row Selection

The row selection state is handled by the row data source provided to the grid, but selection is triggered
by interactions in the grid (for example, clicking a row). LyteNyte Grid fires the `onRowSelect` callback
whenever the user selects rows in the grid. You can use the event parameters to prevent the selection or
take another action that suits your application.

For example, you can use `onRowSelect` to limit the number of selected rows to 3 (or any other number),
as the demo below demonstrates.

::demo[Prevent Row Selection="./demos/row-selection-preventing"]

From the demo code, notice that you can call `preventDefault` to stop the
row selection from happening:

```tsx
onRowSelect={({ preventDefault, rows, deselect, api }) => {
  if (rows === "all" || deselect) return;

  const current = api.rowsSelected().rows;

  const finalSet = new Set([...rows, ...current.map((x) => x.id)]);
  if (finalSet.size > 3) {
    alert("You can only select a maximum of three rows");
    preventDefault(); //!
  }
}}
```

## Row Selection ID Universe

Each row data source maintains what is called the **ID universe**. The **ID universe** is the set of
all possible row IDs currently available in the data source.

- For client-side data, this is the set of all possible rows for the current source configuration.
- For server-side data, this is the set of all loaded rows.

LyteNyte Grid uses the **ID universe** to ensure selected row IDs are valid. In other words, the ID of a
selected row must exist in the grid.

If you want to provide the grid with row IDs that are not currently created but may eventually be
added to the data source, you can supply a set of additional IDs via the
`rowSelectionIdUniverseAdditions` property on the data source, as shown below:

```ts
const ds = useClientDataSource({
  rowSelectionIdUniverseAdditions: new Set(["unloaded-row-1", "unloaded-row-2"]), //!
});
```

Only use `rowSelectionIdUniverseAdditions` when the rows you want to preselect will not be
immediately available in the data source.

## Row Selection Reset Key

The row selection state of a row data source resets when the structure of the view
changes in a way that invalidates existing rows. Common actions that invalidate rows include:

- Row grouping.
- Filtering.
- Sorting (only for server-side data).

The `rowSelectKey` property on the row data source can override the default reset behavior with your own key.
It works much like the dependency array of the `useMemo` or `useCallback` hooks. Provide an array of values,
and LyteNyte Grid shallow-compares the values whenever the key changes.

In the example below, clicking the **Update Key** button forces a row selection reset. The demo does this
by setting `rowSelectKey` to an array containing a count, then incrementing the count whenever the button
is clicked.

::demo[Resetting Row Selection="./demos/row-selection-reset"]

## Next Steps

::next[/docs/row-pinning]
::next[/docs/row-full-width]
::next[/docs/row-detail]
