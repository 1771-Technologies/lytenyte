---
title: Pivot State Persistence
pro: true
step: Persist and load pivot state.
description: LyteNyte Grid dynamically creates columns when pivots are enabled. The state applied to the
  pivots can be controlled to display exactly the configuration your application requires.
---

Since LyteNyte Grid is responsible for creating pivot columns, the state of the pivots is represented
by the `PivotState` type, shown below. The pivot state includes row and column
group expansion state in addition to column-specific state.

```ts
export interface PivotState {
  readonly columnState: {
    readonly ordering: string[];
    readonly resizing: Record<string, number>;
    readonly pinning: Record<string, ColumnPin>;
  };
  readonly columnGroupState: Record<string, boolean>;
  readonly rowGroupExpansions: Record<string, boolean | undefined>;
}
```

By default, the client data source maintains and controls the pivot state internally. This means
pivots support features such as re-ordering and resizing without requiring any external hooks.

## Controlled Pivot State

For more fine-grained control of the pivot state, set the `pivotState` property on the client data source.
You must provide a state object. Set the `onPivotStateChange` property to handle updates to
`pivotState` value.

The demo below demonstrates controlled pivot state in action. The controlled state behaves
identically to the default approach, with the only difference being that the state is now exposed
to the rest of your application.

::demo[Controlled Pivot State="./demos/pivot-persistence"]

The code to control the pivot state is shown below. The initial state starts with the **Canada** row
group collapsed. To control pivot state, the `onPivotStateChange` is set to the `setPivotState` function
returned by React's `useState` hook.

```ts
//!next 5
const [pivotState, setPivotState] = useState<Grid.T.PivotState>({
  columnGroupState: {},
  columnState: { ordering: [], pinning: {}, resizing: {} },
  rowGroupExpansions: { Canada: false },
});

const ds = useClientDataSource<GridSpec>({
  data: salesData,
  pivotMode: true,
  pivotState, //!
  onPivotStateChange: setPivotState, //!
  pivotModel: {
    columns: [{ id: "ageGroup" }],
    rows: [{ id: "country" }, { id: "productCategory" }],
    measures: [
      {
        dim: { id: "profit", name: "Profit", type: "number", cellRenderer: ProfitCell, width: 140 },
        fn: "sum",
      },
    ],
  },
  rowGroupDefaultExpansion: true,
  aggregateFns: { sum: aggSum },
});
```

:::note

Controlling pivot state is not recommended unless your application's use case requires it.
Do not use controlled pivot state to modify columns generated by the client data source.
If you only need to adjust generated columns, `pivotColumnProcessor` is a better choice.

:::

## Next Steps

::next[/docs/pivoting-columns-and-rows]
::next[/docs/pivoting-measures]
::next[/docs/pivoting-sorting]
