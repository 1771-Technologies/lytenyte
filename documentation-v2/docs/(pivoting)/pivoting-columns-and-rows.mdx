---
title: Row & Column Pivots
pro: true
step: Learn how to apply pivot columns and rows to the grid.
description: Configure the pivot rows and columns in the client data source to create views that
  allow you reveal specific aspects about your data.
---

:::note

All the demos in this guide use a single **measure** column: **Profit**.
This simplifies the code examples so that the main focus remains on the
row and column configuration for pivoting. For information on configuring
measures, see the [Measures guide](/docs/pivoting-measures).

:::

## Pivot Columns

Set the `columns` property on the `pivotModel` of the client data source to configure
which columns are used to dynamically generate pivot columns. The values in the
`columns` property are used to create the pivot column definitions.

The demo below demonstrates selecting different columns to pivot on. Try different
pivot column combinations to get a feel for how pivoting behaves.

::demo[Pivot Columns="./demos/pivot-columns"]

Notice that each applied pivot extends the column hierarchy further. Adding more
pivots increases the number of generated columns exponentially. LyteNyte Grid does
not impose a limit on the number of pivots you can apply. Your application should
restrict the number of pivots in a way that best suits your data.

Because no pivot rows are applied, LyteNyte Grid aggregates all rows into a single
total row. See the **Pivot Rows** section of this guide to learn how to add pivot
rows to the view.

:::note

The demo above, and all subsequent demos, use the
[Pill Manager component](/docs/component-pill-manager) to manage pivot configuration.
Using this component is optional. You can use any component that fits your
application's requirements.

:::

### Pivot Column Group Expansions

When more than one pivot column is configured, LyteNyte Grid creates a column group
hierarchy. Because pivots generate these columns dynamically, the column definitions
are not provided directly by your application state.

The client data source manages column group expansion state internally. You can
collapse column groups using the grid's
[`api.columnToggleGroup`](/docs/reference) method.

The demo below shows this behavior. The grid is pivoted on **Age Group** and **Gender**.
A custom header group renderer allows column groups to be collapsed. Notice that the
**Total** columns remain visible even when the group is collapsed.

::demo[Pivot Column Groups="./demos/pivot-columns-expansions"]

### Pivot Column Updates

LyteNyte Grid creates pivot columns dynamically through the client data source. The
client data source also manages updates to these pivot columns internally. This makes
it possible to move or resize generated pivot columns.

The demo below allows you to resize or move pivot columns within the grid. LyteNyte
Grid manages the column state through the client data source.

::demo[Pivot Column State="./demos/pivot-columns-state"]

### Pivot Column Creation

LyteNyte Grid dynamically creates pivot columns based on the provided column
configuration. Set the `pivotColumnProcessor` property on the
`useClientDataSource` hook to modify these columns before they are rendered.

Using `pivotColumnProcessor`, you can modify dynamically created columns in any way
that suits your application. You can reorder or remove columns, or change any column
property.

The demo below uses `pivotColumnProcessor` to remove the **Total** columns created by
the column pivots.

::demo[Remove Totals="./demos/pivot-columns-process"]

The code for the pivot column processor is shown below. The processor returns a new
array of columns based on the columns generated by the grid.

```ts
const ds = useClientDataSource<GridSpec>({
  data: salesData,
  pivotMode: true,
  pivotColumnProcessor: (columns) => {
    return columns.filter((x) => !x.id.includes("total"));
  },
  pivotModel: {
    columns: [{ id: "ageGroup" }, { id: "customerGender" }],
    measures: [
      {
        dim: { id: "profit", name: "Profit", type: "number", cellRenderer: ProfitCell, width: 120 },
        fn: "sum",
      },
    ],
  },
  aggregateFns: { sum: aggSum },
});
```

## Pivot Rows

You can add row groups to a pivot configuration to extend the pivot view along another
dimension. Set the `rows` property on the `pivotModel` to group rows before they are
measured.

Pivot row groups differ from standard row groups in one important way: the final
level of a pivot row group cannot be expanded. This behavior results from how pivot
aggregations work and is an expected outcome of pivoting.

The demo below shows pivot rows in action. Each pivot row creates an additional
grouping level. LyteNyte Grid allows the same column to be used as both a pivot column
and a pivot row.

::demo[Row Pivots="./demos/pivot-rows"]

Because pivoting represents a rotation of the grid view, you can seamlessly swap
row and column pivots. The demo above performs this swap when you click the **Swap**
button.

The demo uses the [Pill Manager component](/docs/component-pill-manager) to configure
pivots. React state stores the pivot configuration and updates it when pills are
clicked or dragged. The updated pivot state is then mapped to the client data source,
as shown in the code below.

```ts
const [colPivots, setColPivots] = useState<PillManager.T.PillItem[]>(initialPivots);
const [rowPivots, setRowPivots] = useState<PillManager.T.PillItem[]>(initialColPivots);

const ds = useClientDataSource<GridSpec>({
  data: salesData,
  pivotMode: true,
  pivotModel: {
    columns: colPivots.filter((x) => x.active),
    rows: rowPivots.filter((x) => x.active),
    measures: [
      {
        dim: { id: "profit", name: "Profit", type: "number", cellRenderer: ProfitCell, width: 120 },
        fn: "sum",
      },
    ],
  },
  aggregateFns: { sum: aggSum },
});
```

## Next Steps

::next[/docs/pivoting-measures]
::next[/docs/pivoting-filtering]
::next[/docs/pivoting-grand-totals]
