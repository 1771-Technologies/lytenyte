---
title: Pivoting Overview
pro: true
description: LyteNyte's pivot functionality lets you create rotated views, allowing
  you to see comparisons, patterns, and trends in your data.
---

Pivoting takes the cell values of a particular column and creates dynamic columns from those values.
You can then apply measures that summarize data from a different column, allowing you to break
the aggregation into the parts that contribute to the pivot column.

:::note

The guides in this section cover pivoting using the
[client row data source](/docs/client-source-overview). For server-side pivoting, see the
[Server Data Pivoting guide](/docs/server-data-loading-pivoting).

For other row data sources, such as the [tree data source](/docs/tree-source-overview) and the
[paginated data source](/docs/paginated-rs-overview), pivoting is not supported because it is not
possible to unambiguously pivot data for these sources.

:::

## Full Example

The demo below shows a complete, working pivoting example that you can use as a reference implementation.
The remaining guides in the pivoting section focus on specific parts of the pivot configuration that
LyteNyte Grid offers.

::demo[Pivot Demo="./demos/pivot-full"]

The remainder of this section explains how to enable basic pivots and provides the foundational knowledge
required to understand the other guides in the pivoting section.

## Pivot Mode

LyteNyte Grid does not maintain internal state. The grid renders exactly the props you provide.
As a result, the grid has no direct knowledge of the current pivot state. Instead, the client row
data source maintains the pivot state.

To enable pivoting, you must do the following:

- Set the `pivotMode` property to `true` on the client data source.
- Provide a `pivotModel` value.
- Call the `usePivotProps` hook on the client data source and pass the returned props to the grid.

The code below shows the minimum configuration required.

```tsx
function PivotGrid() {
  const ds = useClientDataSource<Spec>({
    pivotMode: true,
    pivotModel: {},
  });

  const pivotProps = ds.usePivotProps();

  return <Grid {...pivotProps} />;
}
```

The demo below shows pivoting in action. You can toggle pivot mode on and off.
The grid is hard-coded to pivot on the **Age Group** column, group by the **Country** column,
and measure the **Profit** column.

::demo[Basic Pivoting="./demos/pivot-basic"]

The rows are grouped by **Country**. However, you cannot expand the groups to reveal sub-rows.
This behavior is inherent to pivoting. Pivoted data is always displayed in an aggregated form.
All displayed rows are group rows, and the final level is not expandable.

The code below shows the pivot configuration used in the demo. Pay close attention to the
`measures` value. LyteNyte Grid uses the `measure` definition as a reference when creating
pivot-generated columns. In this example, the **Profit** column serves as the base column
for the newly created pivot columns. The code overrides the column header to make the generated
headers resemble the unpivoted **Age Group** cell values.

```ts
const ds = useClientDataSource<GridSpec>({
  data: salesData,
  pivotMode: pivotMode,
  pivotModel: {
    //!next 12
    columns: [{ id: "ageGroup" }],
    rows: [{ id: "country" }],
    measures: [
      {
        dim: {
          ...columns.find((x) => x.id === "profit")!,
          headerRenderer: AgeGroupPivotHeader,
          width: 120,
        },
        fn: "sum",
      },
    ],
  },
});
```

### Client Source Pivot Model

The `pivotModel` property of the `useClientDataSource` hook defines how LyteNyte Grid renders
pivoted rows. The interface is shown below.

```ts
interface PivotModel<Spec extends GridSpec = GridSpec> {
  readonly columns?: (Column<Spec> | PivotField<Spec>)[];
  readonly rows?: (Column<Spec> | PivotField<Spec>)[];
  readonly measures?: { dim: Column<Spec>; fn: Aggregator<Spec["data"]> | string }[];

  readonly sort?: SortFn<Spec["data"]>;
  readonly filter?: HavingFilterFn | (HavingFilterFn | null)[];
  readonly rowLabelFilter?: (LabelFilter | null)[];
  readonly colLabelFilter?: (LabelFilter | null)[];
}
```

All properties in the pivot model are optional. The `columns`, `rows`, and `measures` properties
determine the structure of the pivot view. Their behavior is as follows:

- If you provide no values for `columns`, `rows`, or `measures`, the pivot view will be blank.
- If `columns` contains one or more entries, LyteNyte Grid uses the cell values from those columns
  to generate dynamic pivot columns.
- If `rows` contains one or more entries, LyteNyte Grid groups the measure output by the specified rows.
- If `measures` is provided, LyteNyte Grid aggregates grid rows using the defined measures. Measure behavior
  depends on which other properties are present:
  1. If only `measures` are provided, LyteNyte Grid creates one column per measure and aggregates all rows,
     resulting in at most one totals row.
  2. If `measures` and `columns` are provided, LyteNyte Grid aggregates measures for each dynamically
     generated pivot column.
  3. If `measures` and `rows` are provided, LyteNyte Grid aggregates measures for each row group.
  4. If `measures`, `rows`, and `columns` are all provided, LyteNyte Grid aggregates measures for each row
     group, split across the dynamically generated pivot columns.

## Next Steps

::next[/docs/pivoting-columns-and-rows]
::next[/docs/pivoting-filtering]
::next[/docs/pivoting-sorting]
