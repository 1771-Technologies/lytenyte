---
title: Cell Edit Renderers
step: Define custom renderers to update a cell in the grid.
description: To enable cell editing, provide an edit renderer for each editable
  column. This guide covers edit renderers for basic data types.
---

## Text Editors

A text edit renderer uses a `<input />` element. In the demo below,
double-click a cell in the **Customer** column to begin text editing.

::demo[Text Edit Renderer="./demos/cell-editing-text-renderer"]

The text editor in the demo uses the [controlled pattern](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)
to manage the input value. Since the editor edits text, it does not require custom parsing. The code
below updates the value directly:

```tsx
function TextCellEditor({ changeValue, editValue }: Grid.T.EditParams<GridSpec>) {
  return (
    <input
      className="focus:outline-ln-primary-50 h-full w-full px-2"
      value={`${editValue}`} //!
      onChange={(e) => changeValue(e.target.value)} //!
    />
  );
}
```

## Number Editors

Number edit renderers can use an `input` with type `number`, but text inputs
with custom number parsing offers better control over the input experience. The
demo below uses a text `input` for the **Price** column and enforces numeric-only values.

::demo[Number Edit Renderer="./demos/cell-editing-number-renderer"]

:::note
The `editSetter` property is set on the **Price** column, ensuring the edit
value is always a valid number.

Users can start editing by pressing any printable key when a cell has focus.
When editing begins this way, LyteNyte Grid uses the pressed
key as the initial edit value.

Since this initial value bypasses the `getNumberValue` callback, the Price column parses
it in `editSetter`, as shown in the code below.

```ts
{
  id: "price",
  type: "number",
  cellRenderer: PriceCell,
  width: 100,
  name: "Price",
  //!next 6
  editSetter: (p) => {
    const currentValue = typeof p.editValue !== "string" ? 0 : getNumberValue(p.editValue) || 0;
    const data = { ...(p.editData as Record<string, unknown>), [p.column.id]: currentValue };

    return data;
  },
  editable: true,
  editRenderer: NumberEditor,
};
```

:::

In the demo, the `input` change handler calls `getNumberValue`, which
parses and validates the input as numeric.

```ts
function NumberEditor({ changeValue, editValue }: Grid.T.EditParams<GridSpec>) {
  return (
    <input
      className="focus:outline-ln-primary-50 h-full w-full px-2"
      value={`${editValue}`}
      onChange={(e) => {
        const value = getNumberValue(e.target.value); //!
        changeValue(value || 0);
      }}
    />
  );
}

//!next 19
const getNumberValue = (e: string) => {
  const value = e.trim();

  // Allow empty input
  if (value === "") return "";

  // Allow minus sign only at the start
  if (value === "-") return "-";

  // Convert to number and check if it's valid
  const number = Number.parseFloat(value);

  if (value && !Number.isNaN(number)) {
    return String(number) + (value.endsWith(".") ? "." : "");
  } else {
    // If not a valid number, revert to previous value
    return value.slice(0, -1) || "";
  }
};
```

This is one approach for creating a number edit renderer. You can also use
a custom input or use a third-party component like
[Ark UI's number input](https://ark-ui.com/docs/components/number-input).

## Date Editors

Editing requirements for dates vary from simple selections to complex ranges
and timezone adjustments. For simple edits, the native browser's date `input`
is an efficient choice. Double-click a cell in the **Purchase Date** column to start editing.

::demo[Date Edit Renderer="./demos/cell-editing-date"]

The date edit renderer uses a native date `input` as an **uncontrolled**
component instead of a **controlled** one.

Controlling browser date inputs with React state can cause invalid states
during manual keyboard entry. To avoid this, keep the date `input`
uncontrolled and track changes. The browser enforces date validity,
and the edit state reflects the latest value.

```tsx
function DateCellEditor({ changeValue, editValue }: Grid.T.EditParams<GridSpec>) {
  const formatted = typeof editValue === "string" && editValue ? format(editValue, "yyyy-MM-dd") : "";
  return (
    <input
      className="focus:outline-ln-primary-50 h-full w-full px-2"
      defaultValue={formatted} //!
      type="date" //!
      //!next 8
      onChange={(e) => {
        const next = new Date(e.target.value);
        try {
          changeValue(format(next, "yyyy-MM-dd"));
        } catch {
          return;
        }
      }}
    />
  );
}
```

## Popover Editors

For columns with a fixed set of values, a dropdown list is a common
editing pattern. While the native `select` element is the simplest option, it has several limitations:

- **Programmatic Control:** You can't force the `select` menu to open when
  editing begins; users must press **Space** or **Enter**.
- **Limited Styling:** `option` elements support minimal CSS customization, which makes consistent styling harder.
- **Poor Scalability:** `select` element works best with a small set of options
  and becomes impractical for large lists of values.

To see the native `select` element in action, double-click any cell in
the **Product** column below to begin editing.

::demo[Native Select Popover="./demos/cell-editing-popover"]

Given the drawbacks of the `select` element, a better alternative is to use a combobox
or custom select component.

The demo below demonstrates this using LyteNyte
Grid's [Smart Select component](/docs/component-smart-select). Double-click any cell in
the **Product** column below to begin editing.

::demo[Smart Product Select="./demos/cell-editing-popover-smart"]

:::note

LyteNyte Grid's [Smart Select component](/docs/component-smart-select) is only available to <ProTag/> users. However,
you can use another open-source combobox component. Below are some good options:

- [Headless UI Combobox](https://headlessui.com/react/combobox)
- [Base UI Combobox](https://base-ui.com/react/components/combobox)
- [React Aria Combobox](https://react-aria.adobe.com/ComboBox)

:::

### Popover Editor Considerations

When you create a custom popover, consider these points:

- **Enter:** LyteNyte Grid commits edits on **Enter**. Many comboboxes use **Enter** to open
  the completion menu. Decide which action **Enter** triggers while editing.
- **ArrowDown:** LyteNyte Grid moves focus to the next cell on **ArrowDown**. Many select
  components use **ArrowDown** to open options. Decide which action **ArrowDown** triggers while editing.
- **Clipping:** Grid cells clip content that exceeds their bounds. To prevent your popover from
  being clipped, use a **React Portal** to render it into the `body` element.
- **Input Triggers:** By default, editing starts when a user presses a printable character.
  If this isn't ideal for your selection component, set `editOnPrintable` to `false` on the column.

## Next Steps

::next[/docs/cell-editing]
::next[/docs/cell-editing-validation]
::next[/docs/cell-editing-full-row]
