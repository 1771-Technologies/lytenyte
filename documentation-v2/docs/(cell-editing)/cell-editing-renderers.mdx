---
title: Cell Edit Renderers
step: Define custom renderers to update a cell in the grid.
description: To edit a cell in LyteNyte Grid, you must provide an edit renderer for each
  column that will be editable. This guide will cover creating edit renderers for basic
  data types.
---

## Text Editors

A text edit renderer is the simplest type of edit renderer you can create. The most straightforward
approach is to use an `<input />` element. The demo below demonstrates this. Double-click
a cell in the **Customer** column to begin editing the cell as text.

::demo[Text Edit Renderer="./demos/cell-editing-text-renderer"]

The text editor in the demo uses the [controlled pattern](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)
to manage the input value. Since the editor edits text, it does not require custom parsing. The code
below updates the value directly:

```tsx
function TextCellEditor({ changeValue, editValue }: Grid.T.EditParams<GridSpec>) {
  return (
    <input
      className="focus:outline-ln-primary-50 h-full w-full px-2"
      value={`${editValue}`} //!
      onChange={(e) => changeValue(e.target.value)} //!
    />
  );
}
```

## Number Editors

A number edit renderer can be as simple as using an `input` with type `number`. However, a much
better input experience is often a text `input` with custom number parsing. The demo
below uses a normal `input` to edit the **Price** column, and it includes special
handling to ensure only numeric values are set.

::demo[Number Edit Renderer="./demos/cell-editing-number-renderer"]

:::note

In the demo code, you will notice that the `editSetter` property is set on the **Price**
column. This ensures that the edit value is always a valid number.

Users can begin editing by pressing any printable key when a cell has focus. When cell
editing starts in this way, LyteNyte Grid uses the pressed key as the initial cell value.

Since this initial value does not go through the `getNumberValue` callback, the column
parses the number in its `editSetter` property, as the code below shows.

```ts
{
  id: "price",
  type: "number",
  cellRenderer: PriceCell,
  width: 100,
  name: "Price",
  //!next 6
  editSetter: (p) => {
    const currentValue = typeof p.editValue !== "string" ? 0 : getNumberValue(p.editValue) || 0;
    const data = { ...(p.editData as Record<string, unknown>), [p.column.id]: currentValue };

    return data;
  },
  editable: true,
  editRenderer: NumberEditor,
};
```

:::

In the demo, the `input` change handler calls `getNumberValue`, as the code below
shows. The `getNumberValue` function parses the input and validates that the
input is a number.

```ts
function NumberEditor({ changeValue, editValue }: Grid.T.EditParams<GridSpec>) {
  return (
    <input
      className="focus:outline-ln-primary-50 h-full w-full px-2"
      value={`${editValue}`}
      onChange={(e) => {
        const value = getNumberValue(e.target.value); //!
        changeValue(value || 0);
      }}
    />
  );
}

//!next 19
const getNumberValue = (e: string) => {
  const value = e.trim();

  // Allow empty input
  if (value === "") return "";

  // Allow minus sign only at the start
  if (value === "-") return "-";

  // Convert to number and check if it's valid
  const number = Number.parseFloat(value);

  if (value && !Number.isNaN(number)) {
    return String(number) + (value.endsWith(".") ? "." : "");
  } else {
    // If not a valid number, revert to previous value
    return value.slice(0, -1) || "";
  }
};
```

This is just one approach to creating a number edit renderer. You could alternatively
use a custom-made number input, or use another library's number input, such as
[Ark UI's number input](https://ark-ui.com/docs/components/number-input).

## Date Editors

Date editing can range from a simple date `input` to a complex set of date
range selections and timezone adjustments. Depending on your application use case,
you may need to use a custom date picker component.

For simple date edits, it is often best to use the native browser date input element, as the demo below
demonstrates. Double-click a cell in the **Purchase Date** column to begin editing.

::demo[Date Edit Renderer="./demos/cell-editing-date"]

The date cell edit renderer uses a standard `input` element. However, if you examine the code,
you will notice that it does not use a controlled value. Instead, the renderer tracks the value as
uncontrolled.

Native browser `date` inputs can enter a bad state when a user types a date via the keyboard
and React controls the value. A simple workaround is to leave the date value uncontrolled and
track changes. The browser ensures the date is valid, and the edit state reflects the latest value.

```tsx
function DateCellEditor({ changeValue, editValue }: Grid.T.EditParams<GridSpec>) {
  const formatted = typeof editValue === "string" && editValue ? format(editValue, "yyyy-MM-dd") : "";
  return (
    <input
      className="focus:outline-ln-primary-50 h-full w-full px-2"
      defaultValue={formatted} //!
      type="date" //!
      //!next 8
      onChange={(e) => {
        const next = new Date(e.target.value);
        try {
          changeValue(format(next, "yyyy-MM-dd"));
        } catch {
          return;
        }
      }}
    />
  );
}
```

## Popover Editors

When a column has an enumerated set of values to choose from, a common editing pattern is to use a
dropdown list to select from the options.

The most basic approach is to use the browser's `select` element with the set of options, as the demo below
demonstrates. However, this approach has a few drawbacks:

- There is no way to force the select element to open when the edit begins. Users must press Space or
  Enter to open the selection menu.
- The option element has limited styling capabilities.
- The `select` element is only useful when there are a small number of options to choose from.

::demo[Product Select="./demos/cell-editing-popover"]

Given the drawbacks of the `select` element, a better alternative is to use a combobox or custom select
component.

The demo below demonstrates this using LyteNyte Grid's [Smart Select component](/docs/component-smart-select).

::demo[Smart Product Select="./demos/cell-editing-popover-smart"]

:::note

LyteNyte Grid's [Smart Select component](/docs/component-smart-select) is only available to <ProTag/> users. However,
you can use another open-source combobox component. Below are some good options:

- [Headless UI Combobox](https://headlessui.com/react/combobox)
- [Base UI Combobox](https://base-ui.com/react/components/combobox)
- [React Aria Combobox](https://react-aria.adobe.com/ComboBox)

:::

### Popover Editor Considerations

When creating a custom popover, there are a few considerations that will impact the
popover's functionality:

- The **Enter** key commits an edit in LyteNyte Grid. Many combobox components use the **Enter**
  key to open the completion menu. Your code must choose which behavior to use.
- The **ArrowDown** key moves focus to the next cell. Many select components use **ArrowDown** to
  open the options list. Like the **Enter** key, your code must choose which behavior to use.
- Cells in LyteNyte Grid do not allow content to overflow their bounds. This means a popover container
  will be clipped if the popover renders inside the cell element. Most dialogs and popovers use a React portal to
  render content in the `body` element, which avoids clipping.
- By default, editing begins when the user presses any printable character over a cell. This behavior
  may be undesirable when you use a selection component. You can disable it by setting the `editOnPrintable`
  property on the column to `false`.

## Next Steps

::next[/docs/cell-editing]
::next[/docs/cell-editing-validation]
::next[/docs/cell-editing-full-row]
