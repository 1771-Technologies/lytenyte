---
title: Grid Theming
step: Review the general theming guide to learn more about styling LyteNyte Grid.
description: LyteNyte Grid is a headless data grid. This guide explains how to theme LyteNyte Grid using
  vanilla CSS or pre-built themes to create a visually polished data grid.
---

:::info

As a headless data grid, LyteNyte Grid applies no colors, fonts, borders, or backgrounds by default.
However, it does include inline styles required for layout calculations and row or column virtualization.
These functional styles should not be overridden. Because inline styles have high specificity,
they are unlikely to be affected unless you deliberately create an extremely specific CSS selector.

:::

## Pre-built Themes

The fastest way to create a visually polished grid is by using one of the built-in LyteNyte Grid themes.
To apply a theme, add the `ln-grid` class to any HTML element above the grid, then
include the class name of the theme you want to use. Ensure you have imported the CSS file
for the themes:

<Tabs>

<Tab label="Core">

```ts
import "@1771technologies/lytenyte-core/grid-full.css";
```

</Tab>

<Tab label="PRO">
```ts
import "@1771technologies/lytenyte-pro/grid-full.css";
```

</Tab>

</Tabs>

LyteNyte Grid provides seven ready-to-use themes. Add the theme class, alongside the
`ln-grid` class, to a parent element of the grid (typically `html` or `body`):

- `ln-teal`: Teal-accent theme.
- `ln-term`: Terminal-style color theme.
- `ln-dark`: Standard dark theme.
- `ln-light`: Standard light theme.
- `ln-shadcn`: A theme based on the Shadcn color tokens. Supports both light and dark mode. Use in projects that adopt shadcn.
- `ln-cotton-candy`: Playful, colorful theme for friendly data grid views.

The demo below shows how each theme looks in practice. For a complete example with
auxiliary components, visit our [live demo](https://www.1771technologies.com/demo) page,
which includes a theme toggle.

::demo[Pre-built LyteNyte Grid Themes="./demos/grid-theming"]

You can also create a custom theme from scratch. LyteNyte Grid is unopinionated about
your styling method and works with any approach.

### CSS Exports

LyteNyte Grid aims to minimize the final bundle size produced by your application, including the size of your bundled CSS.
For this reason, the LyteNyte Grid packages export individual CSS themes so that unused themes can be excluded from your final CSS bundle.
The exports are shown below with a comment explaining their purpose.

```css
/* 
  Contains the design theme token definitions for LyteNyte Grid, excluding colors.
  These tokens are used for spacing, fonts, and shadows.
 */
@import "@1771technologies/lytenyte-pro/design.css";

/* 
  Contains the base grid styles. This export styles grid elements using the colors
  and tokens defined for the grid's theme.
*/
@import "@1771technologies/lytenyte-pro/grid.css";

/*
  These imports define the various color themes. Import them individually
  to include only the colors for a specific theme.
*/
@import "@1771technologies/lytenyte-pro/cotton-candy.css";
@import "@1771technologies/lytenyte-pro/dark.css";
@import "@1771technologies/lytenyte-pro/light.css";
@import "@1771technologies/lytenyte-pro/shadcn.css";
@import "@1771technologies/lytenyte-pro/teal.css";
@import "@1771technologies/lytenyte-pro/term.css";

/*
  Imports all predefined theme colors. Use this when you want to include
  all pre-made color themes in your application.
*/
@import "@1771technologies/lytenyte-pro/all-colors.css";

/* 
  Imports all tokens, colors, and grid styles. This single import contains
  all pre-made CSS provided by LyteNyte Grid.
 */
@import "@1771technologies/lytenyte-pro/grid-full.css";

/*
  Contains the colors for the ln-light and ln-dark themes, but exports the light
  colors under the :root selector and the dark colors under the .dark class.
  Useful for a standard light/dark theme setup.
*/
@import "@1771technologies/lytenyte-pro/light-dark.css";
```

### The LyteNyte Design Tokens

The pre-built LyteNyte themes use a set of design tokens to maintain a consistent look and feel.
These tokens are CSS variables that your application can modify to augment or adjust the existing themes.

- See the [design.css file](https://github.com/1771-Technologies/lytenyte/blob/main/packages/lytenyte-design/src/design.css)
  in our GitHub repository for the definitions of the non-color design tokens.
- See the [ln-dark.css file](https://github.com/1771-Technologies/lytenyte/blob/main/packages/lytenyte-design/src/themes/ln-dark.css)
  in our GitHub repository for the definitions of the color design tokens. All themes use the same set of color token names.

The rest of this guide explains how to style the grid using vanilla CSS and inline styles.
Even if you use a framework like Tailwind, reviewing these examples will help
you understand the styling attributes available in LyteNyte Grid.

## Styling Through Data Attributes

LyteNyte Grid makes extensive use of data attributes on grid elements.
Data attributes are custom pieces of information attached to an HTML element.
They always begin with the `data-` prefix. For example, each cell element includes the
attribute `data-ln-cell="true"`. All LyteNyte Grid data attributes begin with the `data-ln`
prefix, where `ln` stands for LyteNyte. Using these attributes is an effective
way to target specific parts of the grid for CSS styling.

In the demo below, the header cells and grid cells are styled using HSLA color codes and
the [`light-dark`](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/color_value/light-dark)
CSS function, which is useful for specifying theme colors for light and dark color schemes.

::demo[Data Attribute Styling="./demos/data-attributes"]

The CSS uses the [attribute selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Selectors/Attribute_selectors),
as shown below:

```css
.data-styles {
  [data-ln-type="number"] {
    justify-content: end;
  }

  [data-ln-cell="true"] {
    display: flex;
    align-items: center;
    padding-inline: 8px;
    background-color: light-dark(white, hsla(190, 32%, 6%, 1));
    color: light-dark(hsla(175, 6%, 38%, 1), hsla(175, 10%, 86%, 1));
    font-size: 14px;
    border-bottom: 1px solid light-dark(hsla(175, 20%, 95%, 1), hsla(177, 19%, 17%, 1));
  }

  [data-ln-alternate="true"] [data-ln-cell="true"] {
    background-color: light-dark(hsl(0, 27%, 98%), hsl(184, 33%, 8%));
  }

  [data-ln-header-cell="true"] {
    display: flex;
    align-items: center;
    padding-inline: 8px;
    background-color: light-dark(hsla(175, 12%, 92%, 1), hsla(177, 19%, 17%, 1));
    color: light-dark(hsla(177, 19%, 17%, 1), hsla(175, 12%, 92%, 1));
    text-transform: capitalize;
    font-size: 14px;
  }
}
```

Wrap the styles in a `data-styles` class to apply them on a per-grid basis.
If you prefer to apply them globally, remove the wrapper class.

### Commonly Used Data Attributes

It is useful to understand which data attributes apply to each element.
You can inspect the rendered grid in your browser's developer tools, but
the most common attributes are listed below for convenience.

### Header Elements

Each header element includes an attribute indicating its type:

- `Grid.Viewport`: `data-ln-viewport`
- `Grid.Header`: `data-ln-header`
- `Grid.HeaderRow`: `data-ln-header-row`
- `Grid.HeaderGroupCell`: `data-ln-header-group`
- `Grid.HeaderCell`: `data-ln-header-cell`

Additionally, `Grid.HeaderCell` may include `data-ln-header-floating`
to indicate that the cell belongs to the floating header.

Some elements also include attributes for contextual styling. For example,
`Grid.HeaderCell` includes `data-ln-colpin` to indicate the pin
section (`start`, `center`, or `end`). It may also include `data-ln-last-start-pin`
or `data-ln-first-end-pin` to indicate whether the cell is the last in the start section or the first in the end section.

`Grid.HeaderGroupCell` includes attributes describing its state. The
`data-ln-collapsible` attribute indicates that the group cell can collapse,
while `data-ln-collapsed` reflects the current collapse state.

Use these attributes to precisely target header elements for custom styling.

### Row and Cell Elements

Each row and cell element includes an identifying data attribute:

- `Grid.RowsContainer`: `data-ln-rows-container`
- `Grid.RowsTop`: `data-ln-rows-top`
- `Grid.RowsCenter`: `data-ln-rows-center`
- `Grid.RowsBottom`: `data-ln-rows-bottom`
- `Grid.Row`: `data-ln-row`
- `Grid.RowFullWidth`: `data-ln-row` and `data-ln-rowtype="full-width"`
- `Grid.Cell`: `data-ln-cell`

Additional contextual attributes support conditional styling. For example,
`Grid.Row` may include `data-ln-last-top-pin` or `data-ln-first-bottom-pin`
to indicate whether the row is the last top-pinned or first bottom-pinned row.

Using these attributes provides a consistent and reliable way to
target specific parts of LyteNyte Grid for styling.

## Styling Through Classes

LyteNyte Grid provides flexible styling options. Since each component is exposed,
you can apply any number of classes to its elements. Use this approach when you
have an existing design system and want LyteNyte Grid to match it.

::demo[Styling With Classes="./demos/styling-with-classnames"]

The CSS is straightforward. The example below shows how the classes
are applied through the `className` property on the components.

```css
.classes {
  .cell {
    display: flex;
    align-items: center;
    padding-inline: 8px;
    background-color: light-dark(white, hsla(190, 32%, 6%, 1));
    color: light-dark(hsla(175, 6%, 38%, 1), hsla(175, 10%, 86%, 1));
    font-size: 14px;
    border-bottom: 1px solid light-dark(hsla(175, 20%, 95%, 1), hsla(177, 19%, 17%, 1));

    &[data-ln-type="number"] {
      justify-content: flex-end;
    }
  }

  [data-ln-alternate="true"] .cell {
    background-color: light-dark(hsl(0, 27%, 98%), hsl(184, 33%, 8%));
  }

  .header-cell {
    display: flex;
    align-items: center;
    padding-inline: 8px;
    background-color: light-dark(hsla(175, 12%, 92%, 1), hsla(177, 19%, 17%, 1));
    color: light-dark(hsla(177, 19%, 17%, 1), hsla(175, 12%, 92%, 1));
    text-transform: capitalize;
    font-size: 14px;

    &[data-ln-type="number"] {
      justify-content: flex-end;
    }
  }
}
```

## Styling Through Inline Styles

You can also style LyteNyte Grid elements using inline styles. This approach works
well when style values are dynamic and available in JavaScript. For example, a simple
theme editor can be built this way, although it is not generally recommended.

::demo[Inline Styles="./demos/grid-inline-styles"]

Inline styles are applied directly to each component. For example, the `Grid.Cell`
component can use the `style` property as shown below.

```tsx
<Grid.Cell
  key={cell.id}
  cell={cell}
  style={{
    display: "flex",
    alignItems: "center",
    paddingInline: "8px",
    justifyContent: cell.type === "number" ? "flex-end" : "flex-start",
    fontSize: 14,
    background: cellBg,
    color: cellFg,
    borderBottom: "1px solid light-dark(hsla(175, 20%, 95%, 1), hsla(177, 19%, 17%, 1))",
  }}
/>
```

:::info

Use caution when applying inline styles. The same maintainability issues and limitations of
inline styles also apply in LyteNyte Grid. When used selectively,
inline styles can simplify code, but avoid using them for every grid element.

:::

## Styling Elements Not Directly Exposed

Most LyteNyte Grid components are accessible through the headless interface.
However, for convenience, some advanced features are rendered
and controlled internally by LyteNyte Grid. These elements include:

- The row detail container (master detail container).
- The cell selection rectangles.

To style these elements, you must target them directly using CSS.
In most cases, a single selector is enough to apply your styles. If you
are using one of our pre-built themes, these elements are already styled.

### Styling the Row Detail (Master Detail) Container

The example below shows a grid with a single row detail expanded. Styles
for the detail container are applied by targeting the row element
that includes the `data-ln-row-detail` attribute.

::demo[Styling Row Detail="./demos/row-detail-styling"]

The applied styles are simple. Padding is added to the detail container, and a border is
applied to its direct `div` descendant. You can adapt this approach as needed
to fit your use case.

```css
[data-ln-row-detail="true"] {
  padding: 24px;

  & > div {
    border: 1px solid light-dark(rgb(216, 202, 202), rgb(62, 54, 54));
    border-radius: 8px;
    background-color: light-dark(white, transparent);
  }
}
```

### Styling the Cell Selection Rectangle

The cell selection rectangle consists of `div` elements created by LyteNyte Grid
to show the range of selected cells. This is a PRO feature available
in LyteNyte Grid PRO. You can style the selection rectangles using data
attributes, primarily `data-ln-cell-selection-rect`.

::demo[Cell Selection Styling="./demos/cell-selection-rect"]

In this example, the cell selection rectangle is styled using the CSS below,
which targets the selection rectangles generated by LyteNyte Grid
when selection ranges are active. Notice how individual rectangles are selected, as
the selection area is actually a set of split `div`s assembled to visually form the selection rectangle.

```css
[data-ln-cell-selection-rect]:not([data-ln-cell-selection-is-unit="true"]) {
  background-color: rgba(0, 0, 255, 0.08);
  box-sizing: border-box;

  &[data-ln-cell-selection-border-top="true"] {
    border-top: 1px solid rgba(0, 0, 255, 1);
  }
  &[data-ln-cell-selection-border-bottom="true"] {
    border-bottom: 1px solid rgba(0, 0, 255, 1);
  }
  &[data-ln-cell-selection-border-start="true"] {
    border-inline-start: 1px solid rgba(0, 0, 255, 1);
  }
  &[data-ln-cell-selection-border-end="true"] {
    border-inline-end: 1px solid rgba(0, 0, 255, 1);
  }
}
[data-ln-cell-selection-rect][data-ln-cell-selection-is-unit="true"] {
  outline: 1px solid rgba(0, 0, 255, 1);
  outline-offset: -1px;
}
```

## Style Overrides

LyteNyte Grid is headless, but the default view setup is usually the recommended way to render grid cells.
Sometimes you need to apply styles directly to a cell or header, and normal CSS selectors are
insufficient (see the [sticky column group labels demo](/docs/column-groups) for an example).
In these cases, use the `styles` property on the grid to apply CSS classes or
inline styles to specific grid components. For example:

<Tabs>

<Tab label="Style Overrides">

```tsx
<Grid
  //!next 8
  styles={{
    headerGroup: {
      style: {
        position: "sticky",
        insetInlineStart: "var(--ln-start-offset)",
        overflow: "unset",
      },
    },
  }}
/>
```

</Tab>

<Tab label="Full Headless Mode">

```tsx
<Grid>
  <Grid.Viewport>
    <Grid.Header>
      {(cells) => {
        return (
          <Grid.HeaderRow>
            {cells.map((c) => {
              if (c.kind === "group")
                return (
                  <Grid.HeaderGroupCell
                    cell={c}
                    key={c.idOccurrence}
                    //!next 4
                    style={{
                      position: "sticky",
                      insetInlineStart: "var(--ln-start-offset)",
                      overflow: "unset",
                    }}
                  />
                );

              return <Grid.HeaderCell cell={c} key={c.id} />;
            })}
          </Grid.HeaderRow>
        );
      }}
    </Grid.Header>

    <Grid.RowsContainer>
      <Grid.RowsTop />
      <Grid.RowsCenter />
      <Grid.RowsBottom />
    </Grid.RowsContainer>
  </Grid.Viewport>
</Grid>
```

</Tab>

</Tabs>

Both approaches are equivalent, and you do not pay a performance penalty for choosing one over the other.
You also do not need to memoize the `styles` property. LyteNyte Grid diffs the styles object
and notifies cells when the styles change.

For more guidance on the headless setup of LyteNyte Grid,
see the [Headless Component Parts guide](/docs/grid-headless-parts).

## Layout Constraints

LyteNyte Grid is mostly headless and unstyled, but some functional inline
styles are necessary for layout and rendering. These styles control cell
sizing and positioning. Avoid overriding them to ensure the grid renders correctly.

Functional styles typically affect properties such as
`width`, `height`, `top`, `left`, and `transform`. Avoid applying
`margin` directly to grid elements, as it may interfere with layout calculations.

LyteNyte Grid applies its functional styles inline, which gives them high specificity.
As a result, it is difficult to unintentionally override these styles.
In most cases, conflicts will only occur if you create an extremely specific CSS selector.

## Next Steps

This guide covers the main styling approaches for LyteNyte Grid. Since most developers
use a framework or CSS abstraction, we also provide dedicated guides for popular styling methods.

::next[/docs/grid-theming-tailwind]
::next[/docs/grid-theming-css-modules]
::next[/docs/grid-theming-emotion]
