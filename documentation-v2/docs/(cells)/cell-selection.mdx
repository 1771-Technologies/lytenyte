---
title: Cell Range Selection
pro: true
step: See how to select a range of cells, or multiple ranges of cells.
description: LyteNyte Grid supports selecting a range of cells or multiple ranges of cells.
  A range is an rectangular area of cells which can be considered selected.
---

Set the `cellSelectMode` property on the grid to configure the cell selection behavior of
LyteNyte Grid. This property accepts three possible values:

- `"range"`: Allows a single range of cells to be selected.
- `"multi-range"`: Allows multiple cell selection ranges to be performed. Holding down the control/command
  key adds to the existing selections.
- `"none"`: Disables the cell selection functionality in the grid. By default cell selection is disabled.

## Single Range Selection

By setting the `cellSelectMode` to `"range"`, LyteNyte Grid will allow a single rectangular area of
cells to be selected. Cell selection is performed by clicking a cell and dragging over an area to
select. The demo below demonstrates this. Try clicking and dragging a cell to select a range of
cells.

::demo[Range Selection="./demos/cell-selection"]

To enable cell selection the demo sets the `cellSelectMode` mode as the code below shows.

```tsx
<Grid columns={columns} columnBase={base} rowSource={ds} cellSelectMode="range" />
```

### Copy Cell Content

When cell selection is enabled, LyteNyte Grid will track the selection state internally. This
type of cell selection is called **uncontrolled cell selection**. Since the grid manages the selection,
the only way to retrieve the current selection state is to call `cellSelections` on the API

**Uncontrolled cell selection** is useful for implementing functionality such as copying cells to the
clipboard, without needing to manage the cell selection state in your own code. The demo below demonstrates
this. Select some cells and press **Control C** to copy the cells to your clipboard (**Command C** ) on a Mac.

::demo[Copying Cell Content="./demos/cell-selection-copy"]

The copy functionality is implemented using the `keyDown` event on the grid viewport. The implementation code is
shown below. Notice the code uses the `api.cellSelections` method to retrieve the current selection rects. The
grid's `api.exportData` method is then used to retrieve the data for the given selection rect. The retrieved data
is then converted to a string and written to the clipboard. The `copy-flash` class simply flashes the cells to give
some feedback to the user that the cells have been selected.

```tsx
<Grid
  columns={columns}
  columnBase={base}
  rowSource={ds}
  cellSelectMode="range"
  events={useMemo<Grid.Events<GridSpec>>(
    () => ({
      viewport: {
        keyDown: async (ev, vp, api) => {
          if (ev.key === "c" && (ev.metaKey || ev.ctrlKey)) {
            //!next 10
            const rect = api.cellSelections()?.[0];
            if (!rect) return;
            const v = await api.exportData({ rect });

            vp.classList.add("copy-flash");

            const asString = v.data.map((x) => `${x.join(", ")}`).join("\n");
            await navigator.clipboard.writeText(asString);

            setTimeout(() => vp.classList.remove("copy-flash"), 1000);
          }
        },
      },
    }),
    [],
  )}
/>
```

### Controlled Cell Selection

For some use cases taking control of the cell selection is necessary. To do this, set the
`cellSelections` property on the grid to an array of selection rects. You can then provide an
`onCellSelectionChange` handler to update the provided state when the selection changes.

The demo below demonstrates controlled selection. The cell selection state is kept in local
React state through a `useState` hook. The selection state is the passed to a status bar
component that will display the averages of the selections for each number column.

::demo[Status Bar="./demos/cell-selection-status"]

The `cellSelections` property expects an array of `DataRect` objects to be provided. A `DataRect`
is an object with the following interface. The `rowEnd` and `columnEnd` values are exclusive and not included
in the selected cells.

```ts
interface DataRect {
  readonly rowStart: number;
  readonly rowEnd: number;
  readonly columnStart: number;
  readonly columnEnd: number;
}
```

:::note

Do not confused the `cellSelections` API method with the `cellSelections` property on the grid. Though named the same,
these are two distinct properties in LyteNyte.

- The `cellSelections` API method returns the current cell selection rectangles in the grid.
- The `cellSelections` property on the grid controls the state of the cell selection rects.

When cell selection state is controlled, the value returned by the `cellSelection` API method will equal the
value of the `cellSelections` property on the grid.

:::

## Highlight Headers

The headers which have a cell selected will have a data attribute set to `"true"` called `data-ln-cell-selected`.
Using this data attribute, you can style the header to indicate that some cells in the column have been selected.
The demo below demonstrates. The header of any column that has a selected cell will be Highlighted via CSS.

::demo[Header Highlights="./demos/cell-selection-header-highlight"]

The demo uses the [LyteNyte Grid Tailwind plugin](/docs/grid-theming-tailwind) to style the header with this Tailwind CSS class
`"ln-header:data-[ln-cell-selected=true]:bg-ln-primary-05"`. If you are not using Tailwind, this
class is equivalent to the CSS below:

```css
.ln-grid {
  [data-ln-header-cell="true"][data-ln-cell-selected="true"] {
    background-color: var(--ln-primary-05);
  }
}
```

:::tip

The `data-ln-cell-attribute` is also applied to the rows in the grid that contain cells.
This makes it possible to style rows with selected cells as well, as the demo in the next
section does for the marker column.

:::

## Marker Column

The [marker column](/docs/marker-column) is a special column managed and controlled by LyteNyte Grid,
but is not part of the columns provided to the grid. When enabled the marker column will
always be the first column in the viewport. The marker column is always pinned to the start of the grid.

By default the marker column may be part of the row selection rectangle. Depending on your
use case, this may not be desirable. In these cases you can set
the `cellSelectionExcludeMarker` property to `true`, which will cause LyteNyte Grid to disallow any cell
selection of the marker column.

::demo[Exclude Marker Column="./demos/cell-selection-marker"]

The marker column still contributes to the grid's layout even when the `cellSelectionExcludeMarker` value is
set to `true`. This means that regardless of the `cellSelectionExcludeMarker` value, when the marker column is
enabled, the column index of the first non-marker column will be 1.

## Selecting A Column or Row

To select a column or row you can create a select rectangle and set the `cellSelection` value to
that rectangle on the grid. You can do this regardless of the `cellSelectionMode` applied to the
the grid.

The demo below demonstrates this. By clicking the header of a column all the cells in that that column
will be selected. To select a row, click the marker column's cell. By default LyteNyte Grid will clear
the current selection if another element in the grid becomes focused, e.g. the header cell. Since we are
trying to select the column itself the demo sets the `cellSelectionMaintainOnNonCellPosition` property
on the grid. This property ensures that the cell selection is not cleared when the header is clicked.

::demo[Select A Column Or Row="./demos/cell-selection-column-and-row"]

## Selection With Row & Column Spans

When the grid has cell spans

::demo[Cell Selection With Spans="./demos/cell-selection-spans"]

## Cell Selection Across Pin Areas

::demo[Cell Selection With Pins="./demos/cell-selection-pins"]

## Multi Range Selection

::demo[Multiple Range Selections="./demos/cell-selection-multi-range"]
