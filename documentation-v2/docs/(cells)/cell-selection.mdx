---
title: Cell Range Selection
pro: true
step: See how to select a range of cells, or multiple ranges of cells.
description: LyteNyte Grid supports selecting a range of cells or multiple ranges of cells.
  A range is an rectangular area of cells which can be considered selected.
---

Set the `cellSelectionMode` property on the grid to configure the cell selection behavior of
LyteNyte Grid. This property accepts three possible values:

- `"range"`: Allows a single range of cells to be selected.
- `"multi-range"`: Allows multiple cell selection ranges to be performed. Holding down the control/command
  key adds to the existing selections.
- `"none"`: Disables the cell selection functionality in the grid. By default cell selection is disabled.

## Single Range Selection

By setting the `cellSelectionMode` to `"range"`, LyteNyte Grid will allow a single rectangular area of
cells to be selected. Cell selection is performed by clicking a cell and dragging over an area to
select. The demo below demonstrates this. Try clicking and dragging a cell to select a range of
cells.

::demo[Range Selection="./demos/cell-selection"]

To enable cell selection the demo sets the `cellSelectionMode` mode as the code below shows.

```tsx
<Grid columns={columns} columnBase={base} rowSource={ds} cellSelectionMode="range" />
```

### Copy Cell Content

When cell selection is enabled, LyteNyte Grid will track the selection state internally. This
type of cell selection is called **uncontrolled cell selection**. Since the grid manages the selection,
the only way to retrieve the current selection state is to call `cellSelections` on the API

**Uncontrolled cell selection** is useful for implementing functionality such as copying cells to the
clipboard, without needing to manage the cell selection state in your own code. The demo below demonstrates
this. Select some cells and press **Control C** to copy the cells to your clipboard (**Command C** ) on a Mac.

::demo[Copying Cell Content="./demos/cell-selection-copy"]

The copy functionality is implemented using the `keyDown` event on the grid viewport. The implementation code is
shown below. Notice the code uses the `api.cellSelections` method to retrieve the current selection rects. The
grid's `api.exportData` method is then used to retrieve the data for the given selection rect. The retrieved data
is then converted to a string and written to the clipboard. The `copy-flash` class simply flashes the cells to give
some feedback to the user that the cells have been selected.

```tsx
<Grid
  columns={columns}
  columnBase={base}
  rowSource={ds}
  cellSelectionMode="range"
  events={useMemo<Grid.Events<GridSpec>>(
    () => ({
      viewport: {
        keyDown: async (ev, vp, api) => {
          if (ev.key === "c" && (ev.metaKey || ev.ctrlKey)) {
            //!next 10
            const rect = api.cellSelections()?.[0];
            if (!rect) return;
            const v = await api.exportData({ rect });

            vp.classList.add("copy-flash");

            const asString = v.data.map((x) => `${x.join(", ")}`).join("\n");
            await navigator.clipboard.writeText(asString);

            setTimeout(() => vp.classList.remove("copy-flash"), 1000);
          }
        },
      },
    }),
    [],
  )}
/>
```

### Controlled Cell Selection

For some use cases taking control of the cell selection is necessary. To do this, set the
`cellSelections` property on the grid to an array of selection rects. You can then provide an
`onCellSelectionChange` handler to update the provided state when the selection changes.

The demo below demonstrates controlled selection. The cell selection state is kept in local
React state through a `useState` hook. The selection state is the passed to a status bar
component that will display the averages of the selections for each number column.

::demo[Status Bar="./demos/cell-selection-status"]

The `cellSelections` property expects an array of `DataRect` objects to be provided. A `DataRect`
is an object with the following interface. The `rowEnd` and `columnEnd` values are exclusive and not included
in the selected cells.

```ts
interface DataRect {
  readonly rowStart: number;
  readonly rowEnd: number;
  readonly columnStart: number;
  readonly columnEnd: number;
}
```

:::note

Do not confused the `cellSelections` API method with the `cellSelections` property on the grid. Though named the same,
these are two distinct properties in LyteNyte.

- The `cellSelections` API method returns the current cell selection rectangles in the grid.
- The `cellSelections` property on the grid controls the state of the cell selection rects.

When cell selection state is controlled, the value returned by the `cellSelection` API method will equal the
value of the `cellSelections` property on the grid.

:::

## Highlight Headers

The headers which have a cell selected will have a data attribute set to `"true"` called `data-ln-cell-selected`.
Using this data attribute, you can style the header to indicate that some cells in the column have been selected.
The demo below demonstrates. The header of any column that has a selected cell will be Highlighted via CSS.

::demo[Header Highlights="./demos/cell-selection-header-highlight"]

The demo uses the [LyteNyte Grid Tailwind plugin](/docs/grid-theming-tailwind) to style the header with this Tailwind CSS class
`"ln-header:data-[ln-cell-selected=true]:bg-ln-primary-05"`. If you are not using Tailwind, this
class is equivalent to the CSS below:

```css
.ln-grid {
  [data-ln-header-cell="true"][data-ln-cell-selected="true"] {
    background-color: var(--ln-primary-05);
  }
}
```

:::tip

The `data-ln-cell-attribute` is also applied to the rows in the grid that contain cells.
This makes it possible to style rows with selected cells as well, as the demo in the next
section does for the marker column.

:::

## Marker Column

The [marker column](/docs/marker-column) is a special column managed and controlled by LyteNyte Grid,
but is not part of the columns provided to the grid. When enabled the marker column will
always be the first column in the viewport. The marker column is always pinned to the start of the grid.

By default the marker column may be part of the row selection rectangle. Depending on your
use case, this may not be desirable. In these cases you can set
the `cellSelectionExcludeMarker` property to `true`, which will cause LyteNyte Grid to disallow any cell
selection of the marker column.

::demo[Exclude Marker Column="./demos/cell-selection-marker"]

The marker column still contributes to the grid's layout even when the `cellSelectionExcludeMarker` value is
set to `true`. This means that regardless of the `cellSelectionExcludeMarker` value, when the marker column is
enabled, the column index of the first non-marker column will be 1.

## Selecting A Column or Row

To select a column or row you can create a select rectangle and set the `cellSelection` value to
that rectangle on the grid. You can do this regardless of the `cellSelectionMode` applied to the
the grid.

The demo below demonstrates this. By clicking the header of a column all the cells in that that column
will be selected. To select a row, click the marker column's cell. By default LyteNyte Grid will clear
the current selection if another element in the grid becomes focused, e.g. the header cell. Since we are
trying to select the column itself the demo sets the `cellSelectionMaintainOnNonCellPosition` property
on the grid. This property ensures that the cell selection is not cleared when the header is clicked.

::demo[Select A Column Or Row="./demos/cell-selection-column-and-row"]

## Selection With Row & Column Spans

When selecting cells that span more than a single row or column, LyteNyte Grid will expand the
selection range to encompass the full area of the cell that spans. The demo below demonstrates
this behavior. Selecting any of the spanning cells will result in an expanded cell selection area.

::demo[Cell Selection With Spans="./demos/cell-selection-spans"]

## Cell Selection Across Pin Areas

Rows and columns may be frozen in view. These are called pinned rows or pinned columns, and they form pinned areas
in the layout. Pinned areas remain visible even as the user scrolls. When cell selection is enabled, a pinned area
may only be selected if the scroll position of the view allows it:

- Columns pinned to the start of the viewport may only be selected when the grid has no horizontal scroll.
- Columns pinned to the end of the viewport may only be selected when the grid is fully horizontally scrolled.
- Rows pinned to the top of the viewport may only be selected if the grid has no vertical scroll.
- Rows pinned to the bottom of the viewport may only be selected if the grid is fully vertically scrolled.

The above constraints only apply if the selection did not being within the pinned area being selected. LyteNyte Grid
will automatically scroll the grid as the selection is expanded toward the edges of the view. The demo below
has pinned rows top and bottom, and pinned columns start and end. Try selecting the different areas to get a feel
for the selection behavior.

::demo[Cell Selection With Pins="./demos/cell-selection-pins"]

Notice that the selection rectangle appears split when the selection spans more than one pinned area. This is only
a visual indication that the cell selection is spanning over different areas of the viewport. The `cellSelections`
state will still only have a single selection rectangle.

## Multi Range Selection

By setting the `cellSelectionMode` to `"multi-range"`, LyteNyte grid will allow multiple ranges to be selected.
To select ranges additively hold the control/command key down before beginning a selection. If the state of the
selection is already selected, then a deselection will begin instead.

::demo[Multiple Range Selections="./demos/cell-selection-multi-range"]

Multiple ranges are normally used to compare the values in two groups of cells. For other use cases, such as
copying cells, multiple ranges add more complexity. When multiple ranges are selected the state of the
`cellSelections` will contain multiple selection rectangles. For operations, like copying, determining which
selection rect the user wants to copy becomes ambiguous. Unless your use case really does require multiple
ranges, it is often best to set the `cellSelectionMode` to `"range"`.

## Styling Cell Selections

LyteNyte Grid creates a set a `div` elements that are positioned and sized over the cells that are selected.
These `div` elements are inert and are only intended to provide visual feedback. By default, the `div` are
unstyled. To style them you will need to target the cell selection data attributes. The CSS for provided
themes of LyteNyte Grid is shown below for you reference. For more details on styling cell selection rectangles
see the [Grid Theming guide](/docs/grid-theming).

```css
[data-ln-cell-selection-rect]:not([data-ln-cell-selection-is-unit="true"]) {
  background-color: var(--ln-primary-10);
  box-sizing: border-box;

  &[data-ln-cell-selection-is-deselect="true"] {
    background-color: var(--ln-red-30);

    &[data-ln-cell-selection-border-top="true"],
    &[data-ln-cell-selection-border-bottom="true"],
    &[data-ln-cell-selection-border-start="true"],
    &[data-ln-cell-selection-border-end="true"] {
      border-color: var(--ln-red-50);
    }
  }

  &[data-ln-cell-selection-border-top="true"] {
    border-top: 1px solid var(--ln-primary-50);
  }
  &[data-ln-cell-selection-border-bottom="true"] {
    border-bottom: 1px solid var(--ln-primary-50);
  }
  &[data-ln-cell-selection-border-start="true"] {
    border-inline-start: 1px solid var(--ln-primary-50);
  }
  &[data-ln-cell-selection-border-end="true"] {
    border-inline-end: 1px solid var(--ln-primary-50);
  }
}
```

## Next Steps

::next[/docs/cell-renderers]
::next[/docs/cell-tooltips]
::next[/docs/cell-editing-bulk-editing]
