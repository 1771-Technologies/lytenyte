---
title: Clipboard
step: Copy and paste grid data using the clipboard.
pro: true
description: Use the grid's cell selection and export API to copy grid data to the clipboard.
---

Implement clipboard support by combining `exportData` with [cell selection](/docs/cell-selection)
and [bulk data editing](/docs/cell-editing-bulk-editing).
Use this approach to build copy, cut, and paste functionality.

## Clipboard Workflow

The demo below shows clipboard interactions.Click and drag to select
cells. Press `Ctrl+C` to copy, `Ctrl+X` to cut, and `Ctrl+V` to paste.

::demo[Clipboard="./demos/clipboard"]

The code below shows how to handle copy operations. Expand the code in the demo frame to
view the full implementation.

The `handleCopy` function uses the current selection and the `exportData` method to copy
grid cell content to the clipboard. When you pass a `rect` argument, `exportData` returns
only the rows and columns that fall within the specified rectangle.

The `handleGridUpdate` function parses update data and writes it to the grid using
`api.editUpdateCells`. This update data comes from the event handler attached to the grid.

:::note

This sample prioritizes conciseness. In production, treat clipboard data as untrusted
input and validate it using libraries like [Zod](https://zod.dev/)
before applying updates. See the [Cell Editing guide](/docs/cell-editing) for details.

:::

```tsx
const handleCopy = useCallback(async () => {
  if (!api) return;

  const selectionToCopy = getFirstSelection();
  if (!selectionToCopy) return;

  const data = await api.exportData({
    rect: selectionToCopy,
  });

  const stringToCopy = data.data
    .map((row) => {
      return row.map((cell) => `${cell}`).join("\t");
    })
    .join("\n");

  await navigator.clipboard.writeText(stringToCopy);
}, [api, getFirstSelection]);

const handleGridUpdate = useCallback(
  async (updates: unknown[][]) => {
    if (!api) return;
    if (!document.activeElement) return null;

    const position = api.positionFromElement(document.activeElement as HTMLElement);
    if (position?.kind !== "cell") return;

    const map = new Map<number, { column: number; value: any }[]>();

    for (let i = 0; i < updates.length; i++) {
      const rowI = i + position.rowIndex;
      const row = api.rowByIndex(rowI).get();

      if (!row?.data || api.rowIsGroup(row)) continue;

      const data = updates[i];

      const columnUpdates: { column: number; value: any }[] = [];

      for (let j = 0; j < data.length; j++) {
        const colI = j + position.colIndex;

        const column = columns[colI];
        const rawValue = data[j];

        let value = column.type === "number" ? Number.parseFloat(rawValue as string) : rawValue;
        if (column.type === "number" && Number.isNaN(value)) value = String(rawValue);

        columnUpdates.push({ column: colI, value: value });
      }
      map.set(rowI, columnUpdates);
    }

    if (!api.editUpdateCells(map)) alert("Copy operation failed");
  },
  [api],
);
```

## Next Steps

::next[/docs/export-csv]
::next[/docs/export-excel]
::next[/docs/export-arrow]
