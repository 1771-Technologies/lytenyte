---
title: Grid Reactivity
step: Learn how LyteNyte Grid enables declarative reactivity.
description: LyteNyte Grid is a declarative grid. The state you apply
  determines what the grid displays. The design follows the philosophy that
  "view is a function of state."
---

## Props as State

LyteNyte Grid accepts state via props provided to the `Grid` component. The view displayed by the grid
will always respect the props provided. The code below shows a basic example of passing columns to
the grid. You should already be familiar with React, and this approach of passing props to components
should be second nature.

```tsx
const columns: Column[] = [
  { id: "Company", widthFlex: 2 },
  { id: "Country", widthFlex: 2 },
  { id: "Founded", type: "number" },
  { id: "Employee Cnt", name: "Employees", type: "number", cellRenderer: NumberCell },
  { id: "Price", type: "number", cellRenderer: PriceCell },
];

function MyGrid() {
  return <Grid columns={columns} />; //!
}
```

If you are using TypeScript, all the props passed to the grid will be type checked for correctness. Since,
some of the props have generic type parameters, it is sometimes necessary to provide a concrete type to the
grid. An example of this is shown below. See our [TypeScript guide](/docs/prodready-typescript) for more
details.

```tsx
//!next 3
interface GridSpec {
  readonly data: number[];
}

//! next
const columns: Column<GridSpec>[] = [
  { id: "Company", widthFlex: 2 },
  { id: "Country", widthFlex: 2 },
  { id: "Founded", type: "number" },
  { id: "Employee Cnt", name: "Employees", type: "number", cellRenderer: NumberCell },
  { id: "Price", type: "number", cellRenderer: PriceCell },
];

function MyGrid() {
  //!next 3
  // The type param is optional since TypeScript will infer
  // it to be GridSpec from the provided columns
  return <Grid<GridSpec> columns={columns} />;
}
```

### Changing Prop Values

Since LyteNyte Grid accepts props for its state, updating the state of the grid is done
by updating the prop values passed to the grid. For example, to configure the row height
of the grid, different `rowHeight` values may be passed to the grid. The state of the
`rowHeight` value can simply be kept in the value returned by React's `useState` hook.

::demo[Change Row Height="./demos/grid-reactivity-row-height"]

## Controlled State

Some operations performed in LyteNyte Grid may result in a state update. These properties
can either be controlled or uncontrolled in LyteNyte Grid. Such properties include:

- `rowDetailExpansions`
- `columnGroupExpansions`
- `rowGroupColumn`

When these properties are updated a change handler is called if provided. For example, the
state of the row detail expansions can be made **controlled** by providing the grid with
properties for the `rowDetailExpansions` and `onRowDetailExpansionsChange`. The demo below
demonstrates this:

::demo[Controlled Row Detail Expansions="./demos/grid-reactivity-controlled-state"]

:::note

Most state properties automatically become controlled state properties when a value for the
property is provided to the grid (providing a change handler is optional). For example, just
providing the `rowDetailExpansions` state is enough to make row detail expansions change. This
is similar to setting the `value` property on an `input` element, without a corresponding
`onChange` handler, i.e. the value will never change based on changes to the input.

```tsx
<Grid
  rowDetailExpansions={rowDetailExpansions} //!
/>
```

One exception is the `columns` property, which is always controlled. For columns to be
changed by the grid (for example, by resizing through drag actions) a `onColumnsChange`
handler must be provided.

:::

## Memoizing State

Many of the properties provided to LyteNyte Grid are object, function, or array values.
These properties should have stable references to prevent unnecessary re-renders. The
easiest way to enforce a stable reference is to define the property outside of any
component. However, if this is not an option, you can leverage React's `useMemo` and
`useCallback` hooks:

```tsx
function MyGrid() {
  //!next
  const columns = useMemo(() => {
    return [
      { id: "Company", widthFlex: 2 },
      { id: "Country", widthFlex: 2 },
      { id: "Founded", type: "number" },
      { id: "Employee Cnt", name: "Employees", type: "number", cellRenderer: NumberCell },
      { id: "Price", type: "number", cellRenderer: PriceCell },
    ];
  });

  return <Grid columns={columns} />; //!
}
```

Avoid creating and passing objects in the render path of a component. For example, a common
performance problem is defining the `columnBase` property as a plain object:

```tsx
// Don't do this, it results in unnecessary re-renders.
<Grid columnBase={{ width: 100 }} />
```

This practices is not specific to LyteNyte Grid but part and parcel of how React works. Read
the [`useMemo`](https://react.dev/reference/react/useMemo) guide in React's information.

:::tip

React's new [compiler](https://react.dev/learn/react-compiler) is capable of automatically
memoizing values, removing the mental overhead to remember to memo values. See
our [React Compiler guide](/docs/react-compiler) guide learn how to use LyteNyte Grid with
the new compiler.

:::

## Next Steps

::next[/docs/grid-headless-parts]
::next[/docs/grid-events]
::next[/docs/grid-virtualization]
