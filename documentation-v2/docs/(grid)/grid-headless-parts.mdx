---
title: Headless Component Parts
step: Learn about the component parts that make up LyteNyte Grid.
description: LyteNyte Grid is a headless data grid. Each part of the grid is split into
  constituent components that you can compose declaratively to form the grid view.
---

All grid components live on the `Grid` export from the LyteNyte Grid packages.

<Tabs>

<Tab label="Core">

```ts
import { Grid } from "@1771technologies/lytenyte-core";
```

</Tab>

<Tab label="PRO">

```ts
import { Grid } from "@1771technologies/lytenyte-pro";
```

</Tab>

</Tabs>

The `Grid` export is the root component of LyteNyte Grid. The `Grid` component has two
modes depending on whether you pass `children`:

- **Default Mode**: Enabled when the `children` prop is `undefined`. In this mode, the `Grid` component
  renders the headless structure that LyteNyte Grid needs to function in the default setup. This is the
  recommended mode unless you need to attach custom logic to the individual component parts of the grid.
- **Headless Mode**: Enabled when you pass `children` to the `Grid` component. In this mode,
  you must render each grid component part to create a valid view. The component parts are defined
  on the `Grid` component itself. For example, you can render the header using `Grid.Header`.

:::info

Only the components needed to form the grid view live under the `Grid` export. Other LyteNyte Grid
exports, such as row data sources, are separate named exports to allow tree shaking. The `Grid` components
are tightly coupled and must be used together under a common `Grid` component.

:::

The remainder of this guide walks through the individual grid components and then shows a complete
demo example. This guide is best read from top to bottom. For a complete working example,
see the [Getting Started guide](/docs/intro-getting-started).

## Grid Anatomy Overview

The code below offers a high-level overview of the individual parts of
the grid component anatomy. Treat this example as a general outline of the grid structure.

<Tabs>

<Tab label="Headless Mode">

```tsx
<Grid>
  <Grid.Viewport>
    <Grid.Header />
    <Grid.RowsContainer>
      <Grid.RowsTop />
      <Grid.RowsCenter />
      <Grid.RowsBottom />
    </Grid.RowsContainer>
  </Grid.Viewport>
</Grid>
```

</Tab>

<Tab label="Default Mode">

```tsx
<Grid />
```

</Tab>

</Tabs>

## Grid

The `Grid` component acts as the root component for all grid elements. It accepts grid props
as state and provides its `children` with the necessary context for LyteNyte Grid to function.
The `Grid` component also exposes the other component parts as properties.

```tsx
<Grid>{/* Other component parts here. */}</Grid>
```

## Viewport

The `Grid.Viewport` component creates the element that acts as the overflow parent for the grid.
As its name suggests, it defines the visible area of the grid and displays rows and columns based
on the scroll position. The viewport automatically sizes to fit its container. See the
[Responsive Container guide](/docs/grid-container) for details on configuring containers
for the grid.

Adding `Grid.Viewport` to the grid component gives us:

```tsx
<Grid>
  <Grid.Viewport /> {/*! */}
</Grid>
```

`Grid.Viewport` renders a `div` element. It accepts all standard `div` props, including `className` and `style`.
LyteNyte Grid also applies inline styles for grid sizing.

## Header

LyteNyte Grid has a single header container, rendered by the `Grid.Header` component.
The `Grid.Header` component accepts an optional render prop as `children`, which you can use to
customize how header content renders. This means you can use `Grid.Header` in two ways.

The first approach is straightforward: render the `Grid.Header` component.

```tsx
<Grid>
  <Grid.Viewport>
    <Grid.Header /> {/*! */}
  </Grid.Viewport>
</Grid>
```

The second approach uses a render prop passed as `children`, which allows for more fine-grained
control over what the header renders. When using this approach, the render prop must return a
`Grid.HeaderRow`, which must render the header cells as `children`.

The render prop function receives an array of `LayoutHeader` items. Each `LayoutHeader` item describes
the layout of an individual header cell, for example, whether the cell is pinned, or whether the cell
belongs to a column group, a normal header, or a floating header. You can use this information for custom
logic, though the default rendering behavior is usually the best place to start.

```tsx
<Grid>
  <Grid.Viewport>
    {/*!next 13 */}
    <Grid.Header>
      {(cells) => {
        return (
          <Grid.HeaderRow>
            {cells.map((c) => {
              if (c.kind === "group") return <Grid.HeaderGroupCell cell={c} key={c.idOccurrence} />;

              return <Grid.HeaderCell cell={c} key={c.id} />;
            })}
          </Grid.HeaderRow>
        );
      }}
    </Grid.Header>
  </Grid.Viewport>
</Grid>
```

Like the `Grid.Viewport` component, the `Grid.Header`, `Grid.HeaderRow`, `Grid.HeaderGroupCell`,
and `Grid.HeaderCell` components all render a `div` element, and you can pass any `div` prop to them.

The `key` passed to `Grid.HeaderGroupCell` uses `c.idOccurrence`. Split
groups create multiple occurrences of the same header, and each shares
the same `id`. Since React requires unique keys, the grid provides
`idOccurrence`, which combines the group ID with an occurrence count.

## Rows Container

Use the `Grid.RowsContainer` component to render all grid rows.
`Grid.RowsContainer` is similar to `Grid.Header` in that it:

- Acts as the container for the grid's rows.
- Renders a normal `div` element and accepts all the `div` element props.

An updated example is shown below:

```tsx
<Grid>
  <Grid.Viewport>
    <Grid.Header />
    <Grid.RowsContainer /> {/*! */}
  </Grid.Viewport>
</Grid>
```

## Top, Center, and Bottom Rows

LyteNyte Grid splits rows into three component sections:

- **Grid.RowsTop:** For rows that are frozen to the top of the viewport, after the header. These rows remain visible even
  as the user scrolls the viewport.
- **Grid.RowsCenter:** For scrollable rows that render after the top rows.
- **Grid.RowsBottom:** For rows that are frozen to the bottom of the viewport. These rows remain visible even as the user
  scrolls the viewport.

Each section component accepts an optional render prop as `children` that allows more fine-grained control over
how rows and cells render. Like `Grid.Header`, this gives you two approaches for rendering rows.

The default (and simplest) approach renders the row section components without providing a render prop, as shown
below. This code is also identical to the structure used in default mode, so it is equivalent to rendering `<Grid />`.

```tsx
<Grid>
  <Grid.Viewport>
    <Grid.Header />
    <Grid.RowsContainer>
      {/*!next 3 */}
      <Grid.RowsTop />
      <Grid.RowsCenter />
      <Grid.RowsBottom />
    </Grid.RowsContainer>
  </Grid.Viewport>
</Grid>
```

To take more control, provide a render prop as `children` to the row section component. The example below shows this
approach. The render prop receives a `LayoutRow` item. Each `LayoutRow` describes the type of row (a full-width row or a
row with one cell per column), along with properties such as `rowIndex` and `rowPin`. You can use these values to apply
row-specific logic.

The render prop must return a `Grid.Row` or `Grid.RowFullWidth` element. If you return a `Grid.Row`, the `Grid.Row`
must render an array of `Grid.Cell` elements as `children`. These components render `div` elements and accept any `div`
prop.

```tsx
<Grid>
  <Grid.Viewport>
    <Grid.Header />
    <Grid.RowsContainer>
      <Grid.RowsTop />
      {/*!next 13 */}
      <Grid.RowsCenter>
        {(row) => {
          if (row.kind === "full-width") return <Grid.RowFullWidth row={row} />;

          return (
            <Grid.Row key={row.id} row={row}>
              {row.cells.map((cell) => {
                return <Grid.Cell cell={cell} key={cell.id} />;
              })}
            </Grid.Row>
          );
        }}
      </Grid.RowsCenter>
      <Grid.RowsBottom />
    </Grid.RowsContainer>
  </Grid.Viewport>
</Grid>
```

## Putting It All Together

Everything so far has focused on assembling the grid. The example below shows a full working setup that
combines all the parts covered in the previous sections. The demo includes rows pinned to the top and
bottom, column groups, and the full row structure.

::demo[Headless Component Parts="./demos/grid-headless-components"]

## Next Steps

::next[/docs/grid-container]
::next[/docs/grid-api-extensions]
::next[/docs/grid-reactivity]
