---
title: Filtering Text
step: Learn how to create and apply text filters to your client row data.
description: Create custom text filters in LyteNyte Grid to filter rows. This
  guide will cover some common filters that apply to string values in cells.
---

:::note

How you apply a text filter in LyteNyte Grid depends on the row source you are using.
See the following guides for each respective row data source:

- [Client Row Filtering](/docs/client-source-filtering)
- [Server Row Filtering](/docs/server-data-loading-row-filtering)
- [Paginated Row Filtering](/docs/paginated-rs-row-filtering)
- [Infinite Row Filtering](/docs/infinite-rs-row-filtering)
- [Tree Filtering](/docs/tree-source-filtering)

This guide focuses on client row filtering, since server filtering is usually handled by your backend database.
These concepts are equally applicable to all row sources.

:::

## Basic Text Filtering

LyteNyte Grid's filter capabilities are flexible enough to define any type of text
filter. You can filter on **contains**, **begins with**, **ends with**, **exact matching**,
or even **regex matching**.

Create a text filter by defining a function that receives a [row node](/docs/row-overview)
and returns `true` to keep the row, or `false` to remove it.

For example, you can define a function that filters a list of products and keeps only those products
that have `Xbox` in their name:

```ts
const filterXbox: Grid.T.FilterFn<GridSpec["data"]> = (row) => {
  return row.data.product.includes("Xbox");
};
```

The demo below demonstrates this filter. Click the **Show Xbox Only** switch to toggle
the filter state.

::demo[Text Filtering="./demos/text-filtering"]

### Filter Modifiers

Since text filtering is just a function, you can apply modifiers to the filter in an
arbitrary manner. For example, you can perform a case-insensitive filter by converting
all values to lower case:

```ts
const filterXbox: Grid.T.FilterFn<GridSpec["data"]> = (row) => {
  return row.data.product.toLowerCase().includes("xbox");
};
```

In advanced cases you can ignore punctuation, trim whitespace, and treat accented
characters, such as "รก", as normal letters.

```ts
const collator = new Intl.Collator(locale, { sensitivity: "case" });
const filterXbox: Grid.T.FilterFn<GridSpec["data"]> = (row) => {
  const product = row.data.product.trim().replace(/[!"#$%&'()*+,-./:;<=>?@[\\\]^_`{|}~]/g, "");

  return collator.compare("xbox", product);
};
```

## Filter Model

Filtering on text would not be very useful if you could only predefine filters ahead of time.
LyteNyte Grid lets you define your own filter model and operations, which you can then use to
create dynamic filters.

This section shows one approach, and you are encouraged to design filters in a way that directly
suits your application's requirements.

To create a dynamic filter, start by defining the type representation of your text filter. In this
section, the code below defines the filter model.

```ts
export type FilterStringOperator =
  | "equals"
  | "not_equals"
  | "begins_with"
  | "not_begins_with"
  | "ends_with"
  | "not_ends_with"
  | "contains"
  | "not_contains";

export interface FilterString {
  readonly kind: "string";
  readonly operator: FilterStringOperator;
  readonly value: string;
}

export interface GridFilter {
  readonly left: FilterString;
  readonly right: FilterString | null;
  readonly operator: "AND" | "OR";
}

export interface GridSpec {
  readonly data: OrderData;
  readonly api: {
    readonly filterModel: PieceWritable<Record<string, GridFilter>>; //!
  };
}
```

Using this filter model definition, you can create a filter function for the row data source.

The demo below demonstrates this. Click the funnel icon on the **Product**, **Customer**, or
**Email** columns to open the filter popover.

::demo[Filter UI="./demos/text-filter-ui"]

Pay special attention to the code that defines the filter model below. The code creates the filter
model state, which you then pass to the grid's API as an extension. The demo also includes a filter UI that allows users
to apply filters.

When a user applies a filter, `useMemo` creates a new `filterFn` that you then pass to the
client data source. See the `filter.tsx` file in the demo's expanded code for the logic that builds
the filter UI.

```ts
const [filter, setFilter] = useState<Record<string, GridFilter>>({});
const filterModel = usePiece(filter, setFilter);

const filterFn = useMemo(() => {
  const entries = Object.entries(filter);

  const evaluateStringFilter = (operator: FilterStringOperator, compare: string, value: string) => {
    if (operator === "equals") return value === compare;
    if (operator === "begins_with") return compare.startsWith(value);
    if (operator === "ends_with") return compare.endsWith(value);
    if (operator === "contains") return compare.includes(value);
    if (operator === "not_begins_with") return !compare.startsWith(value);
    if (operator === "not_ends_with") return !compare.endsWith(value);
    if (operator === "not_contains") return !compare.includes(value);
    if (operator === "not_equals") return value !== compare;

    return false;
  };

  return entries.map<Grid.T.FilterFn<GridSpec["data"]>>(([column, filter]) => {
    return (row) => {
      //#start
      const value = row.data[column as keyof GridSpec["data"]];

      // This guide only covers string filters, so return false for non-string values.
      if (typeof value !== "string") return false;

      // Case-insensitive match
      const compareValue = value.toLowerCase();

      const leftResult = evaluateStringFilter(
        filter.left.operator,
        compareValue,
        filter.left.value.toLowerCase(),
      );
      if (!filter.right) return leftResult;

      if (filter.operator === "OR") {
        return (
          leftResult ||
          evaluateStringFilter(filter.right.operator, compareValue, filter.right.value.toLowerCase())
        );
      }

      return (
        leftResult &&
        evaluateStringFilter(filter.right.operator, compareValue, filter.right.value.toLowerCase())
      );
      //#end
    };
  });
}, [filter]);
```

## Next Steps

::next[/docs/filtering-numbers]
::next[/docs/filtering-dates]
::next[/docs/filtering-quick-search]
