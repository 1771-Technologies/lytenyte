---
title: Filtering Text
step: Learn how to create and apply text filters to your client row data.
description: Create custom text filters in LyteNyte Grid to filter rows. This
  guide covers common filters that apply to string values in cells.
---

:::note

How you apply a text filter in LyteNyte Grid depends on the row source you use.
See the following guides for each supported row data source:

- [Client Row Filtering](/docs/client-source-filtering)
- [Server Row Filtering](/docs/server-data-loading-row-filtering)
- [Tree Filtering](/docs/tree-source-filtering)

This guide focuses on client row filtering, since server-side filtering is typically handled by your backend database.
The concepts in this guide apply equally to all row sources.

:::

## Basic Text Filtering

LyteNyte Grid provides flexible filter capabilities that let you define any type of text filter.
You can filter on **contains**, **begins with**, **ends with**, **exact matching**, or **regex matching**.

To create a text filter, define a function that receives a [row node](/docs/row-overview)
and returns `true` to keep the row or `false` to remove it.

For example, the following function filters a list of products and keeps only rows
where the product name contains `Xbox`:

```ts
const filterXbox: Grid.T.FilterFn<GridSpec["data"]> = (row) => {
  return row.data.product.includes("Xbox");
};
```

The demo below demonstrates this filter. Click the **Show Xbox Only** switch to toggle
the filter state.

::demo[Text Filtering="./demos/text-filtering"]

### Filter Modifiers

Because text filtering is implemented as a function, you can apply modifiers in any
way that fits your requirements. For example, you can perform a case-insensitive filter
by converting both values to lower case:

```ts
const filterXbox: Grid.T.FilterFn<GridSpec["data"]> = (row) => {
  return row.data.product.toLowerCase().includes("xbox");
};
```

In more advanced cases, you can ignore punctuation, trim whitespace, and treat accented
characters—such as "á"—as normal letters:

```ts
const collator = new Intl.Collator(locale, { sensitivity: "case" });
const filterXbox: Grid.T.FilterFn<GridSpec["data"]> = (row) => {
  const product = row.data.product.trim().replace(/[!"#$%&'()*+,-./:;<=>?@[\\\]^_`{|}~]/g, "");

  return collator.compare("xbox", product);
};
```

## Filter Model

Text filtering becomes more powerful when users can define filters dynamically instead
of relying on predefined logic. LyteNyte Grid lets you define a filter model and a set of
operations that you can use to build dynamic filters.

This section demonstrates one possible approach. You are encouraged to design a filter
model that best fits your application's requirements.

To create a dynamic filter, start by defining a type representation for your text filter.
The following code defines a basic filter model:

```ts
export type FilterStringOperator =
  | "equals"
  | "not_equals"
  | "begins_with"
  | "not_begins_with"
  | "ends_with"
  | "not_ends_with"
  | "contains"
  | "not_contains";

export interface FilterString {
  readonly operator: FilterStringOperator;
  readonly value: string;
}

export interface GridFilter {
  readonly left: FilterString;
  readonly right: FilterString | null;
  readonly operator: "AND" | "OR";
}

export interface GridSpec {
  readonly data: OrderData;
  readonly api: {
    readonly filterModel: PieceWritable<Record<string, GridFilter>>;
  };
}
```

Using this filter model, you can create a filter function for the client row data source.

The demo below shows this approach in action. Click the funnel icon on the **Product**,
**Customer**, or **Email** columns to open the filter popover.

::demo[Filter UI="./demos/text-filter-ui"]

Pay close attention to the code that defines the filter model below. This code creates
the filter model state and passes it to the grid's API as an extension. The demo also
includes a filter UI that allows users to apply filters interactively.

When a user applies a filter, `useMemo` creates a new `filterFn`, which you then pass to
the client data source. See the `filter.tsx` file in the demo's expanded code for the logic
that builds the filter UI.

```ts
const [filter, setFilter] = useState<Record<string, GridFilter>>({});
const filterModel = usePiece(filter, setFilter);

const filterFn = useMemo(() => {
  const entries = Object.entries(filter);

  const evaluateStringFilter = (operator: FilterStringOperator, compare: string, value: string) => {
    if (operator === "equals") return value === compare;
    if (operator === "begins_with") return compare.startsWith(value);
    if (operator === "ends_with") return compare.endsWith(value);
    if (operator === "contains") return compare.includes(value);
    if (operator === "not_begins_with") return !compare.startsWith(value);
    if (operator === "not_ends_with") return !compare.endsWith(value);
    if (operator === "not_contains") return !compare.includes(value);
    if (operator === "not_equals") return value !== compare;

    return false;
  };

  return entries.map<Grid.T.FilterFn<GridSpec["data"]>>(([column, filter]) => {
    return (row) => {
      //#start
      const value = row.data[column as keyof GridSpec["data"]];

      // This guide only covers string filters, so return false for non-string values.
      if (typeof value !== "string") return false;

      // Perform a case-insensitive match
      const compareValue = value.toLowerCase();

      const leftResult = evaluateStringFilter(
        filter.left.operator,
        compareValue,
        filter.left.value.toLowerCase(),
      );

      if (!filter.right) return leftResult;

      if (filter.operator === "OR") {
        return (
          leftResult ||
          evaluateStringFilter(filter.right.operator, compareValue, filter.right.value.toLowerCase())
        );
      }

      return (
        leftResult &&
        evaluateStringFilter(filter.right.operator, compareValue, filter.right.value.toLowerCase())
      );
      //#end
    };
  });
}, [filter]);
```

## Next Steps

::next[/docs/filtering-numbers]
::next[/docs/filtering-dates]
::next[/docs/filtering-quick-search]
