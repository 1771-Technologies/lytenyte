---
title: Server Row Data
pro: true
step: Detailed guide on slicing and loading data from the server.
description: LyteNyte Grid's server data source loads row data in slices and retrieves data on demand.
---

## Server Data Source Hook

To use the server data source in LyteNyte Grid, import
the `useServerDataSource` hook from the `@1771technologies/lytenyte-pro` package.

```ts
import { useServerDataSource } from "@1771technologies/lytenyte-pro";
```

Because this function is a React hook, it must follow
the [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks).

Provide the `useServerDataSource` hook with a `queryFn` callback. The callback retrieves
data from the server. LyteNyte Grid passes it parameters describing the current data
request and expects a promise that resolves to the data response. The full
interfaces and request/response cycle are described in the
[Data Interface guide](/docs/server-data-loading-interface).

```ts
export default function ServerDataDemo() {
  const ds = useServerDataSource<MovieData>({
    queryFn: (params) => {
      // See code example for sample implementation
      return Server(params.requests);
    },
    queryKey: [],
  });
}
```

A complete example of basic server loading is shown below:

::demo[Row Data From Server="./demos/basic-server-data"]

Even when data loads from the server, cell renderers and grid configuration
remain client-side. This example demonstrates the simplest form of server
data loading, only the row data is retrieved from the server.

## Setting Columns From the Server

Sometimes the server defines the column configurations as well. In this case, include the column
definitions with the server response. The example below extends
the `queryFn` to handle this scenario.

::demo[Columns Defined On Server="./demos/server-data-with-columns"]

Here, the client doesn't define columns up front. LyteNyte Grid requests the
initial data, and the server responds with both row data and column
definitions. The `queryFn` then sets the columns on the grid:

```ts
const [columns, setColumns] = useState<Grid.Column<GridSpec>[]>([]);

const queryFn: UseServerDataSourceParams<GridSpec["data"], []>["queryFn"] = useCallback(async (params) => {
  const res = await Server(params.requests);

  if (res.columns) {
    setColumns(
      res.columns.map((x) => {
        return {
          ...x,
          cellRenderer: cellRenderers[x.id as keyof typeof cellRenderers],
        } satisfies Grid.Column<GridSpec>;
      }),
    );
  }

  return res.data;
}, []);
```

## Initial Data Loading State

Before the first request, the server data source sets a reactive
`isLoading` property in its state. Use this property to display
loading indicators or skeleton placeholders while fetching initial data.

```ts
export default function ServerDataDemo() {
  const ds = useServerDataSource<MovieData>({
    queryFn: (params) => Server(params.requests),
  });

  const isLoading = ds.isLoading.useValue(); //!
}
```

The example below shows this in action.
**Do not wait for data to appear**, the response from this demo never resolves:

::demo[Initial Loading State="./demos/always-loading"]

## Initial Data Loading Error

Network requests can fail. Failures may occur during:

- The initial data request.
- A subsequent data request (for example, when scrolling through rows).

This section covers the first case as an introduction to error handling.
See the [Handling Load Failures guide](/docs/server-data-loading-handling-load-failures)
for in-depth coverage and best practices.

::demo[Initial Load Error="./demos/error-loading-initial"]

When the initial request fails, the server data source sets the
reactive `loadError` property:

```ts
const ds = useServerDataSource<MovieData>({
  // ...
});

// Set when the initial data request fails
const error = ds.loadingError.useValue(); //!
```

:::note

LyteNyte Grid can only detect a failed request if the promise returned by the `queryFn` rejects.  
If your implementation catches and handles the rejection internally, the grid will not detect the error.  
This is acceptable when the error is handled intentionally, but it's a common source of confusion.

For example, this `queryFn` never reports a failure:

```ts
const neverFailFetcher = async (params) => {
  try {
    const req = await Server(params);
  } catch {
    // Because the error is caught, the promise never rejects
    return [];
  }
};
```

:::

## Next Steps

::next[/docs/server-data-loading-row-sorting]
::next[/docs/server-data-loading-row-filtering]
::next[/docs/server-data-loading-row-grouping-and-aggregation]
::next[/docs/server-data-loading-handling-load-failures]
