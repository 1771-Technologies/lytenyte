---
title: Server Row Filtering
pro: true
step: Learn how to filter server side rows using the server data source.
description: Filter rows on the server before returning them to the client by sending a
  custom filter model to the server.
---

:::info

This guide provides an overview of filtering with a focus on the server row data source.
For detailed guidance on filtering, refer to the Filtering section, starting with
the [Filter Text guide](/docs/filtering-text).

:::

## Filtering Rows

To filter rows on the server, define a filter model and include it in each data request.
The `useServerDataSource` hook accepts a `queryKey` property, which is an array of dependencies
used for data fetching. When a value in this array changes, the data source resets and fetches a new
set of rows.

Include the filter model in the `queryKey` dependency array. The data source passes the `queryKey`
value to the `queryFn`. The `queryFn` then sends the filter model to the server, which applies the filter
before returning the data.

The following demo passes a custom filter model to the `queryKey` property. Click the funnel
icon in the column header to apply a filter.

::demo[Server Filtering="./demos/filtered-server-data"]

To filter rows, the demo creates a filter model and sends it to the server. The filter model
interface appears below. The server uses the `GridFilter` type to evaluate and filter rows.
This example model is intentionally simple, but your application can use a filter model
with any level of complexity.

```ts
export type FilterStringOperator = "equals" | "not_equals" | "less_than" | "greater_than" | "contains";

export interface FilterString {
  readonly operator: FilterStringOperator;
  readonly value: string;
  readonly kind: "text";
}

export type FilterDateOperator = "before" | "after";

export interface FilterDate {
  readonly operator: FilterDateOperator;
  readonly value: string;
  readonly kind: "date";
}

export type GridFilter = FilterString | FilterDate;
```

To send the filter model to the server, the code adds it to the `queryKey`. The example below
demonstrates this approach. The server evaluates the filter model and removes rows that do
not match the filter criteria.

```ts
//!next
const [filters, setFilters] = useState<Record<string, GridFilter>>({});

const ds = useServerDataSource({
  queryFn: (params) => Server(params.requests, params.queryKey[0]),
  queryKey: [filters] as const, //!
  blockSize: 50,
});
```

This approach represents one way to implement server-side filtering. We recommend aligning
the client-side filter model with the format your server already supports. This alignment
helps the client and server represent filters consistently.

## Next Steps

::next[/docs/server-data-loading-row-grouping-and-aggregation]
::next[/docs/server-data-loading-row-sorting]
::next[/docs/server-data-loading-optimistic-loading]
