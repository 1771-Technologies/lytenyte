---
title: Cell Editing Server Data
pro: true
description: Use the server data source to edit cell values and synchronize those updates with the server.
---

This guide covers handling cell updates through the server data source.
Before proceeding, see the [Cell Editing guide](/docs/cell-editing).

## Server Data Editing

The `useServerDataSource` hook accepts a callback for the `onRowDataChange` property. This
handler runs when the user edits a cell and sends the update request to the
server. The handler runs asynchronously. Once the update completes, you must refresh the grid data,
typically by calling the server data source's `refresh` method.

In the demo below, **double-click** any cell to edit it. After you commit the change,
the cell briefly retains its old value before the grid refreshes. To eliminate this delay,
the next section explains how to optimistically update the client-side value
so changes appear instantly.

::demo[Edit Data Async="./demos/editing-server-data"]

The example implements a basic update handler. In most cases, your update
logic should look similar to the following:

```ts
onRowDataChange: async ({ rows }) => {
  const updates = new Map([...rows.entries()].map(([key, row]) => [key.id, row]));

  await handleUpdate(updates, resetKey);
};
```

### Enabling Optimistic Updates

To apply optimistic updates, enable `rowUpdateOptimistically` on the server data source.
This applies edits on the client before the server responds. Since this setting assumes the server
update will succeed, the change remains client-side until you refresh from the server.
You must still use the `onRowDataChange` callback to send the update to the server and handle errors.

In the demo below, **double-click** any cell to edit it.
The cell value updates when you commit the change.

::demo[Edit Data Async With Optimistic Updates="./demos/editing-server-data-optimistic"]

When optimistic updates are enabled, you can skip calling `refresh` when the optimistic
value matches the expected server result. The server update logic follows this pattern:

```ts
onRowDataChange: async ({ rows }) => {
  const updates = new Map([...rows.entries()].map(([key, row]) => [key.id, row]));

  await handleUpdate(updates, resetKey);
},
rowUpdateOptimistically: true,
```

## Next Steps

::next[/docs/server-data-loading-row-data]
::next[/docs/server-data-loading-row-grouping-and-aggregation]
::next[/docs/server-data-loading-optimistic-loading]
