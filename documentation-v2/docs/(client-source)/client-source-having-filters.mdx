---
title: Client Row Having Filters
step: Use client-side filters to exclude rows after row grouping.
description: Having filters exclude group rows and their children after
  the grid performs grouping. Apply these filters to all groups or target specific depths.
pro: true
---

**Having filters** run after the grid creates row groups. If a filter excludes
a group row, the grid also removes all associated child rows.

This guide covers having filters in the client data source,
not filter types. For client-side filtering, see the [Filter Text](/docs/filtering-text).

:::info

**Having** filters derives from the SQL **HAVING** clause, which filters
grouped results after aggregation. For conceptual background, refer to
the [PostgreSQL HAVING guide](https://neon.com/postgresql/postgresql-tutorial/postgresql-having).

:::

## Applying Having Filters

**Having** filters target aggregated group rows in the client data source.
Review the [Client Row Grouping](/docs/client-source-row-grouping) and
[Client Row Aggregations](/docs/client-source-aggregations) guides for prerequisite knowledge.

To apply a **having** filter, set the `having` property on the client
data source to an array of **Having Filter Functions** (`(HavingFilterFn | null)[]).
This will filter group rows by depth. Null entries skip filtering for that level.

The demo implements a `HavingFilterFn`. The [grid API extension](/docs/grid-api-extensions)
provides the `filterModel` defined in this interface

```ts
export interface GridSpec {
  readonly data: BankData;
  readonly column: { agg: string; allowedAggs: string[] };
  readonly api: {
    filterModel: PieceWritable<FilterModel>;
  };
}
```

The filter model lets you build a filter representation before generating
the filter function from it. The demo uses a custom [floating header row](/docs/column-floating-header)
component that allows users to modify the model's value.

The demo below demonstrates this by providing the `having` property with an array of two items.
The first item is `null`, so the filter skips the top-most group level.
The second item is a filter function, so the filter applies to the second grouping level.

::demo[Having Filter Function="./demos/client-row-having"]

The demo creates the `HavingFilterFn` function by iterating through the filters in the model
and applying them one at a time. The code below shows this.

```ts
const havingFilter = useMemo(() => {
  const model = Object.entries(filterModel).filter(([, f]) => {
    return f.kind && f.value && !Number.isNaN(Number.parseFloat(f.value));
  });

  if (!model.length) return;

  const fn = (row: Grid.T.RowGroup) => {
    for (const [key, f] of model) {
      const value = row.data[key] as number;
      const compare = Number.parseFloat(f.value!);
      if (value == null || typeof value !== "number") return false;

      if (f.kind === "eq" && value !== compare) return false;
      else if (f.kind === "neq" && value === compare) return false;
      else if (f.kind === "ge" && value < compare) return false;
      else if (f.kind === "le" && value > compare) return false;
      else if (f.kind === "lt" && value >= compare) return false;
      else if (f.kind === "gt" && value <= compare) return false;
    }

    return true;
  };

  return [null, fn];
}, [filterModel]);
```

## Next Steps

::next[/docs/client-source-label-filters]
::next[/docs/client-source-filtering]
::next[/docs/client-source-row-grouping]
::next[/docs/client-source-aggregations]
