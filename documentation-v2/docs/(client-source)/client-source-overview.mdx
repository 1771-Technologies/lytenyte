---
title: Client Row Overview
step: Visualize client row data and perform advanced operations such as filtering and sorting.
description: Learn how to handle client-side data to deliver a seamless user experience.
  LyteNyte Grid allows you to display, edit, sort, group, and filter row data directly in the browser.
---

Client data in LyteNyte Grid refers to the complete set of row data available in the browser.
Use client data when you can load all the grid's rows directly into the browser.
A common upper bound is around 10,000 rows, but the practical limit depends on available
network bandwidth for both your server and your users.

## Client Row Source

LyteNyte Grid exposes the `useClientDataSource` hook to create a grid **row source**
for client data. A row source is an object that implements the `RowSource` interface shown below.
You don't implement `RowSource` directly; LyteNyte Grid provides
hooks that generate row sources for each supported data source type.

This guide covers the **Client Row Source**. LyteNyte also includes these row sources:

- [Server Row Source](/docs/server-data-loading-overview): Partially loading large datasets on demand from your backend.
- [Tree Row Source](/docs/tree-source-overview): A client row source for row data stored as an object instead of an array.

```ts
export interface RowSource<T = any> {
  readonly useRowCount: () => number;
  readonly useTopCount: () => number;
  readonly useBottomCount: () => number;
  readonly useRows: () => { get: (i: number) => RowNode<T> | null | undefined; size: number };

  readonly useMaxRowGroupDepth: () => number;

  readonly rowIndexToRowId: (index: number) => string | null | undefined;
  readonly rowIdToRowIndex: (id: string) => number | null | undefined;
  readonly rowByIndex: (row: number) => RowAtom<RowNode<T> | null>;
  readonly rowById: (id: string) => RowNode<T> | null;
  readonly rowParents: (id: string) => string[];
  readonly rowIsSelected: (id: string) => boolean;
  readonly rowChildren: (id: string) => string[];
  readonly rowLeafs: (id: string) => string[];
  readonly rowsBetween: (start: string, end: string) => string[];
  readonly rowInvalidate: (row?: number) => void;
  readonly rowsSelected: () => { state: RowSelectionState; rows: RowNode<T>[] };
  readonly rowSelectionState: () => RowSelectionState;
  readonly useSelectionState: () => RowSelectionState;

  // Methods the LyteNyte will call
  readonly onViewChange: (view: SpanLayout) => void;
  readonly onRowGroupExpansionChange: (deltaChanges: Record<string, boolean>) => void;
  readonly onRowsUpdated: (rows: Map<RowNode<T>, T>) => void;
  readonly onRowsSelected: (params: {
    readonly selected: string[] | "all";
    readonly deselect?: boolean;
    readonly mode: "single" | "multiple" | "none";
  }) => void;
}
```

## Using Client Row Source

The `useClientDataSource` hook requires an array of **data**. Each item in the array
becomes a row in the grid. Updates to the data property declaratively update the
row source. The client row source is therefore **derived state**.

The demo below provides a simple example of how to use the client row source.
The remaining guides in this section explore the different
capabilities of LyteNyte Grid's client data source.

::demo[Client Row Data Source="./demos/client-overview"]

## Next Steps

::next[/docs/client-source-data]
::next[/docs/client-source-filtering]
::next[/docs/client-source-row-sorting]
