---
title: Column Spanning
description: With LyteNyte Grid, cells can span multiple columns. When a cell spans,
  it extends into adjacent columns, and the grid skips rendering any cells it covers.
---

The `colSpan` property on a column definition controls how
many columns a cell spans. It accepts either a number or a function.

- **Provide a number** to apply the same span to all rows.
- **Provide a function** that returns a number to vary the span per row.

Cells always span toward the end of the viewport. A spanning cell
covers the next column, not the previous one.

## Uniform Column Spans

When `colSpan` is a **number**, every cell in the column spans the same number of
adjacent columns for all rows. The grid skips rendering any cells covered
by the span. The demo below shows the **USD Price** column spanning over the
adjacent **GBP Price** column.

!demo:Uniform Column Span="./demos/column-spanning-number_x"

Uniform spans are uncommon and mainly appear in cases where the
visual layout differs from the logical column structure. Hence,
these types of column spans are used sparingly.

```ts
const columns = [
  // other columns,
  { field: 3, id: "price", type: "number", colSpan: 2 },
];
```

## Function Column Spans

You can set `colSpan` to a **function** that returns the span for each row.
This allows dynamic spans based on row data. The demo below merges cells
for rows whose temperature values differ by less than `3`.

!demo:Function Column Span="./demos/column-spanning-fn_x"

The `colSpan` function below shows how flexible span logic can be:

```ts
function joinSimilarTemps(x: CellSpanFnParams<MonthlyTemperature>) {
  if (x.row.kind !== "leaf" || !x.row.data) return 1;

  const temps = x.row.data.temps;
  const myOrder = ordering[x.colIndex - 1];
  const value = temps[myOrder];

  let count = 1;
  let i = x.colIndex; // Index is offset by 1 due to the year column

  while (true) {
    const next = ordering[i];
    if (!next) break;

    const nextValue = temps[next];
    if (Math.abs(nextValue - value) < 3) {
      count++;
      i++;
    } else {
      break;
    }
  }

  return count;
}
```

## Column Span Scanning Distance

For performance, LyteNyte Grid does not pre-calculate all spans.
Instead, it scans backward from the first visible column based on
the scroll position. Control this lookback
using the `colScanDistance` property:

```ts
const grid = Grid.useLyteNyte({
  // Other grid props
  colScanDistance: 100,
});
```

`colScanDistance` must be at least the maximum possible span
in your grid. Ensure no span exceeds this value
to guarantee correct rendering.

<Callout>

LyteNyte Grid uses a scan distance to ensure correctness and performance.
Many grids pre-calculate spans, which limits scalability, or render incorrectly
during scrolling. LyteNyte Grid's model requires you to specify a maximum span,
but it maintains accuracy and performance.

In most real-world cases, a scan distance of 100 is more than enough,
since spans rarely approach this size.

</Callout>

## Next Steps

- [Column Base](/docs/v1/column-base): See the default column values and how to override them.
- [Column Resizing](/docs/v1/column-resizing): Change column widths programmatically or through user interaction.
- [Column ID & Name](/docs/v1/column-header-name): Define user-friendly column names and ensure unique IDs.
- [Column Field](/docs/v1/column-field): Control how a column retrieves each cell's value.
