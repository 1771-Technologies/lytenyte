---
title: Getting Started
description:
  Get started with LyteNyte Grid, a modern React data grid designed for enterprise-scale data challenges.
  Built in React, for React, it enables developers to ship faster and more efficiently than ever before.

  No wrappers. No dependencies. Open code.
---

## Our Motivation

Before LyteNyte Grid, we were trapped in a cycle of frustration with bloated, brittle,
and over-engineered data grid libraries. Every new project
became a ritual of fighting APIs that felt like they were written by a
committee that never used React.

Here's what we kept running into again and again:

- **Customization was a nightmare.** Clunky, opaque APIs made even basic tweaks feel like defusing
  a bomb. Two-way data bindings, state sync issues between React and the grid... we've seen things.

- **Server data loading was a disaster.** Optimistic updates, partial rendering, and caching
  never worked properly, or worse, worked sometimes, which is somehow more dangerous.

- **Performance collapsed under pressure.** Beyond trivial datasets, most grids fell apart.
  Virtualization failed. Re-renders multiplied. Main thread got blocked. Users rage-quit.

- **Breaking changes broke more than code.** New versions came with surprises, and not the
  fun kind. We were refactoring the same grid logic every quarter just to stay afloat.

- **Styling was their way or no way.** We were forced to adopt unfamiliar styling systems
  just to make things look half-decent, adding yet another layer of complexity.

- **Bundle sizes were obscene.** Grid libraries ballooned app load times by 1-3
  seconds. That's not just technical debt; it's user abandonment in disguise.

So‚Ä¶ We patched, duct-taped, forked, and cursed. Over time, our quick fixes turned into long-term liabilities.
Technical debt grew. Dev velocity dropped. Maintenance costs soared.
All because the tools we relied on couldn't keep up.

We built **LyteNyte Grid** to end that cycle.

## Why LyteNyte Grid Stands Out

At the heart of LyteNyte Grid is a commitment to the developer and user experience
based on the principle of 'seamless simplicity.'

Here's why we stand out:

- ‚öõÔ∏è **Clean, Declarative API:** LyteNyte Grid exposes a minimal, declarative API aligned with
  React's data flow and state model. No wrappers, no adapter layers.
  No awkward integrations, only cleaner, more maintainable code.

- üì¶ **Tiny Bundle Size:** Core edition is a tiny **30kb gzipped**, while the PRO edition weighs
  only **40kb gzipped**, so you no longer have to choose between advanced
  functionality and a fast user experience.

- ‚ö° **Unrivaled Speed:** LyteNyte can handle **10,000+ updates per second** and render millions of rows.
  Our reactive state architecture means performance doesn't degrade when paginating,
  filtering, or pulling from the server.

- üß© **Headless by Design, Components Included:** An industry first. Ultimate flexibility to choose
  between our pre-styled themes or drop into full headless mode for 100% control.
  Covering any use case you may have for a data table.

- üè¢ **Feature-Rich, Enterprise Ready:** Handles the most demanding workflows with a
  comprehensive feature set that includes pivot tables, tree data, server-side loading,
  custom cell rendering, rich cell editing, and more, all from a single package, giving
  you one consistent API to build with.

- ü´∂ **Simple Licensing, Transparent Support:** Straightforward licensing that won't
  leave you guessing what's permissible. All support is handled publicly on
  GitHub, giving you complete transparency into our response times.

## Core Edition vs. PRO Edition

LyteNyte Grid is available in two editions: **Core** and **PRO**.

LyteNyte Grid PRO is built on top of LyteNyte Grid Core, meaning it includes all Core features plus additional
advanced capabilities for the most demanding enterprise use cases. This architecture
ensures a seamless upgrade path; you can start with Core and switch to PRO
later without refactoring, as it's a non-breaking, drop-in replacement.

- **LyteNyte Core Edition:** Free, open source ([Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0)),
  and genuinely useful. Includes essential features such as sorting, filtering, row grouping, column auto-sizing,
  detail views, data exporting, and others.

- **LyteNyte Grid PRO Edition:** A commercial edition ([EULA](https://www.1771technologies.com/eula))
  with advanced capabilities like server data loading, column and filter manager components,
  tree data, column pivoting, and more sophisticated data table tools.

To determine if a feature is exclusively part of the PRO edition, look for the <ProTag /> icon
next to the feature name on the navigation bar.

For a complete feature comparison between Core and PRO, check
out our [price page](https://www.1771technologies.com/pricing).

## Quick Start

In this guide, you will build a data table inspired by the log tables in Vercel and DataDog.

::demo[Getting Started="./demos/getting-started"]

This demo shows the final output of the guide. If you prefer to jump straight
to the complete code, fork the working demo by clicking the StackBlitz or Code Sandbox icon
under the code frame.

### Installing LyteNyte Grid

This guide works with either edition of LyteNyte Grid. If you have a license, install PRO. You
can use PRO without a license, but the page will show a watermark.

<PackageInstall package="@1771technologies/lytenyte-pro" />

<div children="For Core:" className="text-[16px]" style={{ marginBottom: -10 }} />

<PackageInstall package="@1771technologies/lytenyte-core" />

:::info

If you do not have a React project yet, we recommend using
[Vite](https://vite.dev/). Create a project quickly with:

```sh
pnpm create vite
```

For details, see the
[Vite getting started docs](https://vite.dev/guide/#scaffolding-your-first-vite-project).

:::

### Importing LyteNyte Grid

LyteNyte Grid uses a modular design to minimize bundle size. It exposes named
exports to maximize tree-shaking.

The main export is the `Grid` function, which is a React component that has additional
component functions attached to it. For this guide, only the `Grid` function is required.
See the [Headless Component Parts](/docs/grid-headless-parts) for advanced usage of the
different component parts that make up LyteNyte Grid.

Start by:

1. Importing the `Grid` function.
2. Defining the Grid columns.

The code below shows each part. The rest of this guide will build on the code below,
so if you are following along in your editor be sure to copy it.

```tsx
import "@1771technologies/lytenyte-pro/light-dark.css";
import { Grid } from "@1771technologies/lytenyte-pro";

//!next "1" 1
const columns: Grid.Column<GridSpec>[] = [
  { id: "Date", name: "Date", width: 200, type: "datetime" },
  { id: "Status", name: "Status", width: 100 },
  { id: "Method", name: "Method", width: 100 },
  { id: "timing-phase", name: "Timing Phase" },
  { id: "Pathname", name: "Pathname" },
  { id: "Latency", name: "Latency", width: 120, type: "number" },
  { id: "region", name: "Region" },
];

export default function GettingStarted() {
  return (
    //!next "2" 1
    <div className="ln-grid" style={{ height: 400 }}>
      {/*!next "3" 1 */}
      <Grid columns={columns} />
    </div>
  );
}
```

The lines that are annotated mark important lines:

1. Defines our set of column definitions. This is what the grid will use to display content.
   For more on the different properties see the [Column Overview guide](/docs/columns).
2. Creates a container for the grid that is `400px` tall. LyteNyte Grid is virtualized by default,
   and so requires a container with height to fill. See the [Responsive Container guide](/docs/grid-container)
   for different approaches to creating a container for the grid. The container has the `ln-grid` class applied.
   This class is required for the pre-made styles provided by LyteNyte Grid. For more on styling the grid see
   the [Grid Theming](/docs/grid-theming) guide.
3. The grid itself is rendered. This is the default usage of the grid, however, LyteNyte Grid may be used
   in a headless fashion by providing the `children`. For more on headless
   usage see our [Headless Component Parts guide](/docs/grid-headless-parts).

### Providing Data to the Grid

LyteNyte Grid reads data from a row data source. The most common option is a
client-side data source, which should be used when all row data is available in the browser.

Next we will:

1. Import our row data and data source.
2. Create a row data source using our imported data and give it to the grid.

```tsx
import "@1771technologies/lytenyte-pro/light-dark.css";
import { Grid, useClientDataSource } from "@1771technologies/lytenyte-pro"; //! "1"

import { requestData, type RequestData } from "./data.js"; //! "2"

//!next "3" 3
interface GridSpec {
  data: RequestData;
}

const columns: Grid.Column<GridSpec>[] = [
  { id: "Date", name: "Date", width: 200, type: "datetime" },
  { id: "Status", name: "Status", width: 100 },
  { id: "Method", name: "Method", width: 100 },
  { id: "timing-phase", name: "Timing Phase" },
  { id: "Pathname", name: "Pathname" },
  { id: "Latency", name: "Latency", width: 120, type: "number" },
  { id: "region", name: "Region" },
];

export default function GettingStarted() {
  //!next "4" 3
  const ds = useClientDataSource<GridSpec>({
    data: requestData,
  });

  return (
    <div className="ln-grid" style={{ height: 400 }}>
      <Grid columns={columns} rowSource={ds} /> {/*! */}
    </div>
  );
}
```

The annotated code marks the important changes to make.

1. Import the `useClientDataSource` hook from the LyteNyte package. We are using the client data source
   hook as all the data for our grid will be imported to the users browser.
2. Import the `requestData` from the `./data.js` file. Here we are assuming you've downloaded the
   data for this guide and created a `data.js` (or `data.ts`) file. The data is available in
   our GitHub repository [here](<https://github.com/1771-Technologies/lytenyte/blob/main/documentation/content/docs/(introduction)/demos/getting-started/data.ts>).
   Download or copy the file and create a local `data.js` file in the same folder as the file that
   has the grid.
3. Create a `GridSpec` type. LyteNyte Grid leverages TypeScript for code completion and type checking.
   The grid cannot know ahead of time what the type of the row data will be, so we define a **specification interface**
   and provide it to the type parameter of the various grid types. The specification can do more than just define
   the type of data for the grid and we will see this later in the guide. For more information on best practices for
   TypeScript with LyteNyte Grid see our [TypeScript guide](/docs/prodready-typescript).
4. Call the `useClientDataSource` hook and provide it with our `requestData`. Then set the `rowSource` property on the grid to
   the `ds` value returned from the `useClientDataSource` hook.

If you've followed along to this point you will have a grid that is functional, but still very basic. The demo
below shows an example of what it would be. The example is very plain, and not all the columns have a value.
This is because LyteNyte Grid's default cell renderer is only capable of displaying simple values for a column,
such as strings or numbers. For complex values we need to provide a custom cell renderer. We will do that next.

::demo[Basic Grid="./demos/getting-started_functional"]

## Custom Cell Renderers

A custom cell renderer is a normal React component. LyteNyte Grid will provide the cell renderer with
properties specific to the cell, defined by the [CellRendererParams](/docs/reference/cells#cellrendererparams)
type.

A cell renderer is set on the column definitions provided to the grid. Let's start by defining a cell renderer
for the **Timing Phase** column. The code block has the implementation collapsed as the actual code the goes
into a cell renderer is any arbitrary React content you can think of. The key takeaway is the function
definition. Defining a cell renderer is as easy as creating a new React component that accepts the
`CellRendererParams`. Notice that we've also provided the `GridSpec` type for better type checking.

```tsx
//# start
import type { CellRendererParams } from "@1771technologies/lytenyte-pro-experimental/types";
const colors = ["var(--transfer)", "var(--dns)", "var(--connection)", "var(--ttfb)", "var(--tls)"];
//# end

export function TimingPhaseCell({ api, row }: CellRendererParams<GridSpec>) {
  //# start
  // Guard against rows that are not leafs or rows that have no data.
  if (!api.rowIsLeaf(row) || !row.data) return;

  const total =
    row.data["timing-phase.connection"] +
    row.data["timing-phase.dns"] +
    row.data["timing-phase.tls"] +
    row.data["timing-phase.transfer"] +
    row.data["timing-phase.ttfb"];

  const connectionPer = (row.data["timing-phase.connection"] / total) * 100;
  const dnsPer = (row.data["timing-phase.dns"] / total) * 100;
  const tlPer = (row.data["timing-phase.tls"] / total) * 100;
  const transferPer = (row.data["timing-phase.transfer"] / total) * 100;
  const ttfbPer = (row.data["timing-phase.ttfb"] / total) * 100;

  const values = [connectionPer, dnsPer, tlPer, transferPer, ttfbPer];

  return (
    <div className="flex h-full w-full items-center">
      <div className="flex h-4 w-full items-center gap-px overflow-hidden">
        {values.map((v, i) => {
          return (
            <div
              key={i}
              style={{ width: `${v}%`, background: colors[i] }}
              className={clsx("h-full rounded-sm")}
            />
          );
        })}
      </div>
    </div>
  );
  //# end
}
```

Now that we know how to define cell renderers we can set the cell renderer property on our
columns. The updated column code is shown below.

```tsx
//# start
import "./main.css";
import "@1771technologies/lytenyte-pro-experimental/light-dark.css";
import { Grid, useClientDataSource } from "@1771technologies/lytenyte-pro-experimental";

import type { RequestData } from "./data.js";
import { requestData } from "./data.js";

export interface GridSpec {
  data: RequestData;
}
//# end

import {
  DateCell,
  LatencyCell,
  MethodCell,
  PathnameCell,
  RegionCell,
  StatusCell,
  TimingPhaseCell,
} from "./components.js";

//!next 9
const columns: Grid.Column<GridSpec>[] = [
  { id: "Date", name: "Date", width: 200, type: "datetime", cellRenderer: DateCell },
  { id: "Status", name: "Status", width: 100, cellRenderer: StatusCell },
  { id: "Method", name: "Method", width: 100, cellRenderer: MethodCell },
  { id: "timing-phase", name: "Timing Phase", cellRenderer: TimingPhaseCell },
  { id: "Pathname", name: "Pathname", cellRenderer: PathnameCell },
  { id: "Latency", name: "Latency", width: 120, type: "number", cellRenderer: LatencyCell },
  { id: "region", name: "Region", cellRenderer: RegionCell },
];

//# start
export default function GettingStartedDemo() {
  const ds = useClientDataSource<GridSpec>({
    data: requestData,
  });

  return (
    <div className="ln-grid" style={{ height: 400 }}>
      <Grid columns={columns} rowSource={ds} />
    </div>
  );
}
//# end
```

:::note

We use Tailwind CSS for styling components. LyteNyte Grid has no opinion on styling framework
used, but if you are following along line by line that to correctly render the cell renderers
you will need to [setup Tailwind](https://tailwindcss.com/docs/installation/using-vite), and
add our [theme configuration (todo)](/theme).

Additionally the cell renders use some custom CSS properties for some of the colors. The CSS
for this is shown below:

```css
:root {
  --transfer: #7badff;
  --dns: #126cff;
  --connection: #053f9e;
  --ttfb: #7c8193;
  --tls: #c0c7d1;
}

.dark {
  --transfer: #2be4ce;
  --dns: #03b6a1;
  --connection: #008c7b;
  --ttfb: #6a6c73;
  --tls: #bfc3c9;
}
```

For more on general grid theming and best practices see our [Grid Theming guide](/docs/grid-theming).

:::

The cell renderers are defined in the `components.js` file. You can either create this
yourself or copy our implementation
from [GitHub](<https://github.com/1771-Technologies/lytenyte/blob/main/documentation/content/docs/(introduction)/demos/getting-started/components.tsx>).
A full working example is show below, which you could also fork to CodeSandbox or StackBlitz.

::demo[Cell Renderers="./demos/getting-started_cell-renderers"]

We now have a nice looking grid, but there is still more we can add. In the sections that follow
we will:

1. Add the ability to sort the columns in the grid. We will do this by extending our definition of
   what a column is in the grid with a custom `sort` property.
2. Make every row in the grid a master detail which can be expanded to reveal more information about
   our data.

All the features we will use are available in both the Core and PRO editions of LyteNyte Grid, so you can
follow along regardless of the edition you are using.

## Column Sorting

LyteNyte Grid can sort the rows in the grid by a specific column. To do this we will:

1. Extend our 'definition' of a column with a "sort" property.
2. Make our columns a part of React state, so that we can update them using the LyteNyte Grid API.
3. Provide a custom header renderer which will sort on a column when clicked.

We can start by extending our column definition by updating the `GridSpec` interface, as shown below:

## Row Master Detail

## Next Steps

Explore more LyteNyte Grid capabilities:

- [Row Data Sources](/docs/row-data-source-intro): Create and use various row data sources.
- [Column Definitions](/docs/columns): Review all column configuration options.
- [Grid Atoms & Reactivity](/docs/grid-reactivity): Learn how LyteNyte Grid enables declarative reactivity.
- [API Reference](/docs/reference): Browse all exported interfaces and types.
